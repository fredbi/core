// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mocks

import (
	"iter"
	"sync"

	"github.com/fredbi/core/genmodels/generators/golang-models/data-model"
	"github.com/fredbi/core/genmodels/generators/golang-models/ifaces"
	"github.com/fredbi/core/json"
	"github.com/fredbi/core/json/dynamic"
	"github.com/fredbi/core/jsonschema/analyzers/structural"
)

// Ensure that MockNameProvider does implement ifaces.NameProvider.
// If this is not the case, regenerate this file with mockery.
var _ ifaces.NameProvider = &MockNameProvider{}

// MockNameProvider is a mock implementation of ifaces.NameProvider.
//
//	func TestSomethingThatUsesNameProvider(t *testing.T) {
//
//		// make and configure a mocked ifaces.NameProvider
//		mockedNameProvider := &MockNameProvider{
//			DeconflictAliasFunc: func(name string, namespace structural.Namespace) (string, error) {
//				panic("mock out the DeconflictAlias method")
//			},
//			DeconflictPathFunc: func(name string, namespace structural.Namespace) (string, error) {
//				panic("mock out the DeconflictPath method")
//			},
//			DeconflictSchemaFunc: func(name string, namespace structural.Namespace) (string, error) {
//				panic("mock out the DeconflictSchema method")
//			},
//			FileNameFunc: func(name string, analyzed structural.AnalyzedSchema) string {
//				panic("mock out the FileName method")
//			},
//			FileNameForTestFunc: func(name string, analyzed structural.AnalyzedSchema) string {
//				panic("mock out the FileNameForTest method")
//			},
//			MapExtensionFunc: func(directive string, extension dynamic.JSON) (any, error) {
//				panic("mock out the MapExtension method")
//			},
//			NameEnumValueFunc: func(index int, enumValue json.Document, analyzed structural.AnalyzedSchema) (string, error) {
//				panic("mock out the NameEnumValue method")
//			},
//			NamePackageFunc: func(path string, analyzed structural.AnalyzedPackage) (string, error) {
//				panic("mock out the NamePackage method")
//			},
//			NameSchemaFunc: func(name string, analyzed structural.AnalyzedSchema) (string, error) {
//				panic("mock out the NameSchema method")
//			},
//			PackageAliasFunc: func(name string, part int, analyzed ...structural.AnalyzedSchema) string {
//				panic("mock out the PackageAlias method")
//			},
//			PackageFullNameFunc: func(name string, analyzed ...structural.AnalyzedSchema) string {
//				panic("mock out the PackageFullName method")
//			},
//			PackageShortNameFunc: func(name string, analyzed ...structural.AnalyzedSchema) string {
//				panic("mock out the PackageShortName method")
//			},
//			SetAnnotatorFunc: func(annotator ifaces.Annotator)  {
//				panic("mock out the SetAnnotator method")
//			},
//			SetAuditorFunc: func(auditor ifaces.Auditor)  {
//				panic("mock out the SetAuditor method")
//			},
//			SetMarkerFunc: func(marker ifaces.Marker)  {
//				panic("mock out the SetMarker method")
//			},
//			UniquePathFunc: func(path string) structural.Ident {
//				panic("mock out the UniquePath method")
//			},
//			UniqueSchemaFunc: func(name string) structural.Ident {
//				panic("mock out the UniqueSchema method")
//			},
//		}
//
//		// use mockedNameProvider in code that requires ifaces.NameProvider
//		// and then make assertions.
//
//	}
type MockNameProvider struct {
	// DeconflictAliasFunc mocks the DeconflictAlias method.
	DeconflictAliasFunc func(name string, namespace structural.Namespace) (string, error)

	// DeconflictPathFunc mocks the DeconflictPath method.
	DeconflictPathFunc func(name string, namespace structural.Namespace) (string, error)

	// DeconflictSchemaFunc mocks the DeconflictSchema method.
	DeconflictSchemaFunc func(name string, namespace structural.Namespace) (string, error)

	// FileNameFunc mocks the FileName method.
	FileNameFunc func(name string, analyzed structural.AnalyzedSchema) string

	// FileNameForTestFunc mocks the FileNameForTest method.
	FileNameForTestFunc func(name string, analyzed structural.AnalyzedSchema) string

	// MapExtensionFunc mocks the MapExtension method.
	MapExtensionFunc func(directive string, extension dynamic.JSON) (any, error)

	// NameEnumValueFunc mocks the NameEnumValue method.
	NameEnumValueFunc func(index int, enumValue json.Document, analyzed structural.AnalyzedSchema) (string, error)

	// NamePackageFunc mocks the NamePackage method.
	NamePackageFunc func(path string, analyzed structural.AnalyzedPackage) (string, error)

	// NameSchemaFunc mocks the NameSchema method.
	NameSchemaFunc func(name string, analyzed structural.AnalyzedSchema) (string, error)

	// PackageAliasFunc mocks the PackageAlias method.
	PackageAliasFunc func(name string, part int, analyzed ...structural.AnalyzedSchema) string

	// PackageFullNameFunc mocks the PackageFullName method.
	PackageFullNameFunc func(name string, analyzed ...structural.AnalyzedSchema) string

	// PackageShortNameFunc mocks the PackageShortName method.
	PackageShortNameFunc func(name string, analyzed ...structural.AnalyzedSchema) string

	// SetAnnotatorFunc mocks the SetAnnotator method.
	SetAnnotatorFunc func(annotator ifaces.Annotator)

	// SetAuditorFunc mocks the SetAuditor method.
	SetAuditorFunc func(auditor ifaces.Auditor)

	// SetMarkerFunc mocks the SetMarker method.
	SetMarkerFunc func(marker ifaces.Marker)

	// UniquePathFunc mocks the UniquePath method.
	UniquePathFunc func(path string) structural.Ident

	// UniqueSchemaFunc mocks the UniqueSchema method.
	UniqueSchemaFunc func(name string) structural.Ident

	// calls tracks calls to the methods.
	calls struct {
		// DeconflictAlias holds details about calls to the DeconflictAlias method.
		DeconflictAlias []struct {
			// Name is the name argument value.
			Name string
			// Namespace is the namespace argument value.
			Namespace structural.Namespace
		}
		// DeconflictPath holds details about calls to the DeconflictPath method.
		DeconflictPath []struct {
			// Name is the name argument value.
			Name string
			// Namespace is the namespace argument value.
			Namespace structural.Namespace
		}
		// DeconflictSchema holds details about calls to the DeconflictSchema method.
		DeconflictSchema []struct {
			// Name is the name argument value.
			Name string
			// Namespace is the namespace argument value.
			Namespace structural.Namespace
		}
		// FileName holds details about calls to the FileName method.
		FileName []struct {
			// Name is the name argument value.
			Name string
			// Analyzed is the analyzed argument value.
			Analyzed structural.AnalyzedSchema
		}
		// FileNameForTest holds details about calls to the FileNameForTest method.
		FileNameForTest []struct {
			// Name is the name argument value.
			Name string
			// Analyzed is the analyzed argument value.
			Analyzed structural.AnalyzedSchema
		}
		// MapExtension holds details about calls to the MapExtension method.
		MapExtension []struct {
			// Directive is the directive argument value.
			Directive string
			// Extension is the extension argument value.
			Extension dynamic.JSON
		}
		// NameEnumValue holds details about calls to the NameEnumValue method.
		NameEnumValue []struct {
			// Index is the index argument value.
			Index int
			// EnumValue is the enumValue argument value.
			EnumValue json.Document
			// Analyzed is the analyzed argument value.
			Analyzed structural.AnalyzedSchema
		}
		// NamePackage holds details about calls to the NamePackage method.
		NamePackage []struct {
			// Path is the path argument value.
			Path string
			// Analyzed is the analyzed argument value.
			Analyzed structural.AnalyzedPackage
		}
		// NameSchema holds details about calls to the NameSchema method.
		NameSchema []struct {
			// Name is the name argument value.
			Name string
			// Analyzed is the analyzed argument value.
			Analyzed structural.AnalyzedSchema
		}
		// PackageAlias holds details about calls to the PackageAlias method.
		PackageAlias []struct {
			// Name is the name argument value.
			Name string
			// Part is the part argument value.
			Part int
			// Analyzed is the analyzed argument value.
			Analyzed []structural.AnalyzedSchema
		}
		// PackageFullName holds details about calls to the PackageFullName method.
		PackageFullName []struct {
			// Name is the name argument value.
			Name string
			// Analyzed is the analyzed argument value.
			Analyzed []structural.AnalyzedSchema
		}
		// PackageShortName holds details about calls to the PackageShortName method.
		PackageShortName []struct {
			// Name is the name argument value.
			Name string
			// Analyzed is the analyzed argument value.
			Analyzed []structural.AnalyzedSchema
		}
		// SetAnnotator holds details about calls to the SetAnnotator method.
		SetAnnotator []struct {
			// Annotator is the annotator argument value.
			Annotator ifaces.Annotator
		}
		// SetAuditor holds details about calls to the SetAuditor method.
		SetAuditor []struct {
			// Auditor is the auditor argument value.
			Auditor ifaces.Auditor
		}
		// SetMarker holds details about calls to the SetMarker method.
		SetMarker []struct {
			// Marker is the marker argument value.
			Marker ifaces.Marker
		}
		// UniquePath holds details about calls to the UniquePath method.
		UniquePath []struct {
			// Path is the path argument value.
			Path string
		}
		// UniqueSchema holds details about calls to the UniqueSchema method.
		UniqueSchema []struct {
			// Name is the name argument value.
			Name string
		}
	}
	lockDeconflictAlias  sync.RWMutex
	lockDeconflictPath   sync.RWMutex
	lockDeconflictSchema sync.RWMutex
	lockFileName         sync.RWMutex
	lockFileNameForTest  sync.RWMutex
	lockMapExtension     sync.RWMutex
	lockNameEnumValue    sync.RWMutex
	lockNamePackage      sync.RWMutex
	lockNameSchema       sync.RWMutex
	lockPackageAlias     sync.RWMutex
	lockPackageFullName  sync.RWMutex
	lockPackageShortName sync.RWMutex
	lockSetAnnotator     sync.RWMutex
	lockSetAuditor       sync.RWMutex
	lockSetMarker        sync.RWMutex
	lockUniquePath       sync.RWMutex
	lockUniqueSchema     sync.RWMutex
}

// DeconflictAlias calls DeconflictAliasFunc.
func (mock *MockNameProvider) DeconflictAlias(name string, namespace structural.Namespace) (string, error) {
	if mock.DeconflictAliasFunc == nil {
		panic("MockNameProvider.DeconflictAliasFunc: method is nil but NameProvider.DeconflictAlias was just called")
	}
	callInfo := struct {
		Name      string
		Namespace structural.Namespace
	}{
		Name:      name,
		Namespace: namespace,
	}
	mock.lockDeconflictAlias.Lock()
	mock.calls.DeconflictAlias = append(mock.calls.DeconflictAlias, callInfo)
	mock.lockDeconflictAlias.Unlock()
	return mock.DeconflictAliasFunc(name, namespace)
}

// DeconflictAliasCalls gets all the calls that were made to DeconflictAlias.
// Check the length with:
//
//	len(mockedNameProvider.DeconflictAliasCalls())
func (mock *MockNameProvider) DeconflictAliasCalls() []struct {
	Name      string
	Namespace structural.Namespace
} {
	var calls []struct {
		Name      string
		Namespace structural.Namespace
	}
	mock.lockDeconflictAlias.RLock()
	calls = mock.calls.DeconflictAlias
	mock.lockDeconflictAlias.RUnlock()
	return calls
}

// DeconflictPath calls DeconflictPathFunc.
func (mock *MockNameProvider) DeconflictPath(name string, namespace structural.Namespace) (string, error) {
	if mock.DeconflictPathFunc == nil {
		panic("MockNameProvider.DeconflictPathFunc: method is nil but NameProvider.DeconflictPath was just called")
	}
	callInfo := struct {
		Name      string
		Namespace structural.Namespace
	}{
		Name:      name,
		Namespace: namespace,
	}
	mock.lockDeconflictPath.Lock()
	mock.calls.DeconflictPath = append(mock.calls.DeconflictPath, callInfo)
	mock.lockDeconflictPath.Unlock()
	return mock.DeconflictPathFunc(name, namespace)
}

// DeconflictPathCalls gets all the calls that were made to DeconflictPath.
// Check the length with:
//
//	len(mockedNameProvider.DeconflictPathCalls())
func (mock *MockNameProvider) DeconflictPathCalls() []struct {
	Name      string
	Namespace structural.Namespace
} {
	var calls []struct {
		Name      string
		Namespace structural.Namespace
	}
	mock.lockDeconflictPath.RLock()
	calls = mock.calls.DeconflictPath
	mock.lockDeconflictPath.RUnlock()
	return calls
}

// DeconflictSchema calls DeconflictSchemaFunc.
func (mock *MockNameProvider) DeconflictSchema(name string, namespace structural.Namespace) (string, error) {
	if mock.DeconflictSchemaFunc == nil {
		panic("MockNameProvider.DeconflictSchemaFunc: method is nil but NameProvider.DeconflictSchema was just called")
	}
	callInfo := struct {
		Name      string
		Namespace structural.Namespace
	}{
		Name:      name,
		Namespace: namespace,
	}
	mock.lockDeconflictSchema.Lock()
	mock.calls.DeconflictSchema = append(mock.calls.DeconflictSchema, callInfo)
	mock.lockDeconflictSchema.Unlock()
	return mock.DeconflictSchemaFunc(name, namespace)
}

// DeconflictSchemaCalls gets all the calls that were made to DeconflictSchema.
// Check the length with:
//
//	len(mockedNameProvider.DeconflictSchemaCalls())
func (mock *MockNameProvider) DeconflictSchemaCalls() []struct {
	Name      string
	Namespace structural.Namespace
} {
	var calls []struct {
		Name      string
		Namespace structural.Namespace
	}
	mock.lockDeconflictSchema.RLock()
	calls = mock.calls.DeconflictSchema
	mock.lockDeconflictSchema.RUnlock()
	return calls
}

// FileName calls FileNameFunc.
func (mock *MockNameProvider) FileName(name string, analyzed structural.AnalyzedSchema) string {
	if mock.FileNameFunc == nil {
		panic("MockNameProvider.FileNameFunc: method is nil but NameProvider.FileName was just called")
	}
	callInfo := struct {
		Name     string
		Analyzed structural.AnalyzedSchema
	}{
		Name:     name,
		Analyzed: analyzed,
	}
	mock.lockFileName.Lock()
	mock.calls.FileName = append(mock.calls.FileName, callInfo)
	mock.lockFileName.Unlock()
	return mock.FileNameFunc(name, analyzed)
}

// FileNameCalls gets all the calls that were made to FileName.
// Check the length with:
//
//	len(mockedNameProvider.FileNameCalls())
func (mock *MockNameProvider) FileNameCalls() []struct {
	Name     string
	Analyzed structural.AnalyzedSchema
} {
	var calls []struct {
		Name     string
		Analyzed structural.AnalyzedSchema
	}
	mock.lockFileName.RLock()
	calls = mock.calls.FileName
	mock.lockFileName.RUnlock()
	return calls
}

// FileNameForTest calls FileNameForTestFunc.
func (mock *MockNameProvider) FileNameForTest(name string, analyzed structural.AnalyzedSchema) string {
	if mock.FileNameForTestFunc == nil {
		panic("MockNameProvider.FileNameForTestFunc: method is nil but NameProvider.FileNameForTest was just called")
	}
	callInfo := struct {
		Name     string
		Analyzed structural.AnalyzedSchema
	}{
		Name:     name,
		Analyzed: analyzed,
	}
	mock.lockFileNameForTest.Lock()
	mock.calls.FileNameForTest = append(mock.calls.FileNameForTest, callInfo)
	mock.lockFileNameForTest.Unlock()
	return mock.FileNameForTestFunc(name, analyzed)
}

// FileNameForTestCalls gets all the calls that were made to FileNameForTest.
// Check the length with:
//
//	len(mockedNameProvider.FileNameForTestCalls())
func (mock *MockNameProvider) FileNameForTestCalls() []struct {
	Name     string
	Analyzed structural.AnalyzedSchema
} {
	var calls []struct {
		Name     string
		Analyzed structural.AnalyzedSchema
	}
	mock.lockFileNameForTest.RLock()
	calls = mock.calls.FileNameForTest
	mock.lockFileNameForTest.RUnlock()
	return calls
}

// MapExtension calls MapExtensionFunc.
func (mock *MockNameProvider) MapExtension(directive string, extension dynamic.JSON) (any, error) {
	if mock.MapExtensionFunc == nil {
		panic("MockNameProvider.MapExtensionFunc: method is nil but NameProvider.MapExtension was just called")
	}
	callInfo := struct {
		Directive string
		Extension dynamic.JSON
	}{
		Directive: directive,
		Extension: extension,
	}
	mock.lockMapExtension.Lock()
	mock.calls.MapExtension = append(mock.calls.MapExtension, callInfo)
	mock.lockMapExtension.Unlock()
	return mock.MapExtensionFunc(directive, extension)
}

// MapExtensionCalls gets all the calls that were made to MapExtension.
// Check the length with:
//
//	len(mockedNameProvider.MapExtensionCalls())
func (mock *MockNameProvider) MapExtensionCalls() []struct {
	Directive string
	Extension dynamic.JSON
} {
	var calls []struct {
		Directive string
		Extension dynamic.JSON
	}
	mock.lockMapExtension.RLock()
	calls = mock.calls.MapExtension
	mock.lockMapExtension.RUnlock()
	return calls
}

// NameEnumValue calls NameEnumValueFunc.
func (mock *MockNameProvider) NameEnumValue(index int, enumValue json.Document, analyzed structural.AnalyzedSchema) (string, error) {
	if mock.NameEnumValueFunc == nil {
		panic("MockNameProvider.NameEnumValueFunc: method is nil but NameProvider.NameEnumValue was just called")
	}
	callInfo := struct {
		Index     int
		EnumValue json.Document
		Analyzed  structural.AnalyzedSchema
	}{
		Index:     index,
		EnumValue: enumValue,
		Analyzed:  analyzed,
	}
	mock.lockNameEnumValue.Lock()
	mock.calls.NameEnumValue = append(mock.calls.NameEnumValue, callInfo)
	mock.lockNameEnumValue.Unlock()
	return mock.NameEnumValueFunc(index, enumValue, analyzed)
}

// NameEnumValueCalls gets all the calls that were made to NameEnumValue.
// Check the length with:
//
//	len(mockedNameProvider.NameEnumValueCalls())
func (mock *MockNameProvider) NameEnumValueCalls() []struct {
	Index     int
	EnumValue json.Document
	Analyzed  structural.AnalyzedSchema
} {
	var calls []struct {
		Index     int
		EnumValue json.Document
		Analyzed  structural.AnalyzedSchema
	}
	mock.lockNameEnumValue.RLock()
	calls = mock.calls.NameEnumValue
	mock.lockNameEnumValue.RUnlock()
	return calls
}

// NamePackage calls NamePackageFunc.
func (mock *MockNameProvider) NamePackage(path string, analyzed structural.AnalyzedPackage) (string, error) {
	if mock.NamePackageFunc == nil {
		panic("MockNameProvider.NamePackageFunc: method is nil but NameProvider.NamePackage was just called")
	}
	callInfo := struct {
		Path     string
		Analyzed structural.AnalyzedPackage
	}{
		Path:     path,
		Analyzed: analyzed,
	}
	mock.lockNamePackage.Lock()
	mock.calls.NamePackage = append(mock.calls.NamePackage, callInfo)
	mock.lockNamePackage.Unlock()
	return mock.NamePackageFunc(path, analyzed)
}

// NamePackageCalls gets all the calls that were made to NamePackage.
// Check the length with:
//
//	len(mockedNameProvider.NamePackageCalls())
func (mock *MockNameProvider) NamePackageCalls() []struct {
	Path     string
	Analyzed structural.AnalyzedPackage
} {
	var calls []struct {
		Path     string
		Analyzed structural.AnalyzedPackage
	}
	mock.lockNamePackage.RLock()
	calls = mock.calls.NamePackage
	mock.lockNamePackage.RUnlock()
	return calls
}

// NameSchema calls NameSchemaFunc.
func (mock *MockNameProvider) NameSchema(name string, analyzed structural.AnalyzedSchema) (string, error) {
	if mock.NameSchemaFunc == nil {
		panic("MockNameProvider.NameSchemaFunc: method is nil but NameProvider.NameSchema was just called")
	}
	callInfo := struct {
		Name     string
		Analyzed structural.AnalyzedSchema
	}{
		Name:     name,
		Analyzed: analyzed,
	}
	mock.lockNameSchema.Lock()
	mock.calls.NameSchema = append(mock.calls.NameSchema, callInfo)
	mock.lockNameSchema.Unlock()
	return mock.NameSchemaFunc(name, analyzed)
}

// NameSchemaCalls gets all the calls that were made to NameSchema.
// Check the length with:
//
//	len(mockedNameProvider.NameSchemaCalls())
func (mock *MockNameProvider) NameSchemaCalls() []struct {
	Name     string
	Analyzed structural.AnalyzedSchema
} {
	var calls []struct {
		Name     string
		Analyzed structural.AnalyzedSchema
	}
	mock.lockNameSchema.RLock()
	calls = mock.calls.NameSchema
	mock.lockNameSchema.RUnlock()
	return calls
}

// PackageAlias calls PackageAliasFunc.
func (mock *MockNameProvider) PackageAlias(name string, part int, analyzed ...structural.AnalyzedSchema) string {
	if mock.PackageAliasFunc == nil {
		panic("MockNameProvider.PackageAliasFunc: method is nil but NameProvider.PackageAlias was just called")
	}
	callInfo := struct {
		Name     string
		Part     int
		Analyzed []structural.AnalyzedSchema
	}{
		Name:     name,
		Part:     part,
		Analyzed: analyzed,
	}
	mock.lockPackageAlias.Lock()
	mock.calls.PackageAlias = append(mock.calls.PackageAlias, callInfo)
	mock.lockPackageAlias.Unlock()
	return mock.PackageAliasFunc(name, part, analyzed...)
}

// PackageAliasCalls gets all the calls that were made to PackageAlias.
// Check the length with:
//
//	len(mockedNameProvider.PackageAliasCalls())
func (mock *MockNameProvider) PackageAliasCalls() []struct {
	Name     string
	Part     int
	Analyzed []structural.AnalyzedSchema
} {
	var calls []struct {
		Name     string
		Part     int
		Analyzed []structural.AnalyzedSchema
	}
	mock.lockPackageAlias.RLock()
	calls = mock.calls.PackageAlias
	mock.lockPackageAlias.RUnlock()
	return calls
}

// PackageFullName calls PackageFullNameFunc.
func (mock *MockNameProvider) PackageFullName(name string, analyzed ...structural.AnalyzedSchema) string {
	if mock.PackageFullNameFunc == nil {
		panic("MockNameProvider.PackageFullNameFunc: method is nil but NameProvider.PackageFullName was just called")
	}
	callInfo := struct {
		Name     string
		Analyzed []structural.AnalyzedSchema
	}{
		Name:     name,
		Analyzed: analyzed,
	}
	mock.lockPackageFullName.Lock()
	mock.calls.PackageFullName = append(mock.calls.PackageFullName, callInfo)
	mock.lockPackageFullName.Unlock()
	return mock.PackageFullNameFunc(name, analyzed...)
}

// PackageFullNameCalls gets all the calls that were made to PackageFullName.
// Check the length with:
//
//	len(mockedNameProvider.PackageFullNameCalls())
func (mock *MockNameProvider) PackageFullNameCalls() []struct {
	Name     string
	Analyzed []structural.AnalyzedSchema
} {
	var calls []struct {
		Name     string
		Analyzed []structural.AnalyzedSchema
	}
	mock.lockPackageFullName.RLock()
	calls = mock.calls.PackageFullName
	mock.lockPackageFullName.RUnlock()
	return calls
}

// PackageShortName calls PackageShortNameFunc.
func (mock *MockNameProvider) PackageShortName(name string, analyzed ...structural.AnalyzedSchema) string {
	if mock.PackageShortNameFunc == nil {
		panic("MockNameProvider.PackageShortNameFunc: method is nil but NameProvider.PackageShortName was just called")
	}
	callInfo := struct {
		Name     string
		Analyzed []structural.AnalyzedSchema
	}{
		Name:     name,
		Analyzed: analyzed,
	}
	mock.lockPackageShortName.Lock()
	mock.calls.PackageShortName = append(mock.calls.PackageShortName, callInfo)
	mock.lockPackageShortName.Unlock()
	return mock.PackageShortNameFunc(name, analyzed...)
}

// PackageShortNameCalls gets all the calls that were made to PackageShortName.
// Check the length with:
//
//	len(mockedNameProvider.PackageShortNameCalls())
func (mock *MockNameProvider) PackageShortNameCalls() []struct {
	Name     string
	Analyzed []structural.AnalyzedSchema
} {
	var calls []struct {
		Name     string
		Analyzed []structural.AnalyzedSchema
	}
	mock.lockPackageShortName.RLock()
	calls = mock.calls.PackageShortName
	mock.lockPackageShortName.RUnlock()
	return calls
}

// SetAnnotator calls SetAnnotatorFunc.
func (mock *MockNameProvider) SetAnnotator(annotator ifaces.Annotator) {
	if mock.SetAnnotatorFunc == nil {
		panic("MockNameProvider.SetAnnotatorFunc: method is nil but NameProvider.SetAnnotator was just called")
	}
	callInfo := struct {
		Annotator ifaces.Annotator
	}{
		Annotator: annotator,
	}
	mock.lockSetAnnotator.Lock()
	mock.calls.SetAnnotator = append(mock.calls.SetAnnotator, callInfo)
	mock.lockSetAnnotator.Unlock()
	mock.SetAnnotatorFunc(annotator)
}

// SetAnnotatorCalls gets all the calls that were made to SetAnnotator.
// Check the length with:
//
//	len(mockedNameProvider.SetAnnotatorCalls())
func (mock *MockNameProvider) SetAnnotatorCalls() []struct {
	Annotator ifaces.Annotator
} {
	var calls []struct {
		Annotator ifaces.Annotator
	}
	mock.lockSetAnnotator.RLock()
	calls = mock.calls.SetAnnotator
	mock.lockSetAnnotator.RUnlock()
	return calls
}

// SetAuditor calls SetAuditorFunc.
func (mock *MockNameProvider) SetAuditor(auditor ifaces.Auditor) {
	if mock.SetAuditorFunc == nil {
		panic("MockNameProvider.SetAuditorFunc: method is nil but NameProvider.SetAuditor was just called")
	}
	callInfo := struct {
		Auditor ifaces.Auditor
	}{
		Auditor: auditor,
	}
	mock.lockSetAuditor.Lock()
	mock.calls.SetAuditor = append(mock.calls.SetAuditor, callInfo)
	mock.lockSetAuditor.Unlock()
	mock.SetAuditorFunc(auditor)
}

// SetAuditorCalls gets all the calls that were made to SetAuditor.
// Check the length with:
//
//	len(mockedNameProvider.SetAuditorCalls())
func (mock *MockNameProvider) SetAuditorCalls() []struct {
	Auditor ifaces.Auditor
} {
	var calls []struct {
		Auditor ifaces.Auditor
	}
	mock.lockSetAuditor.RLock()
	calls = mock.calls.SetAuditor
	mock.lockSetAuditor.RUnlock()
	return calls
}

// SetMarker calls SetMarkerFunc.
func (mock *MockNameProvider) SetMarker(marker ifaces.Marker) {
	if mock.SetMarkerFunc == nil {
		panic("MockNameProvider.SetMarkerFunc: method is nil but NameProvider.SetMarker was just called")
	}
	callInfo := struct {
		Marker ifaces.Marker
	}{
		Marker: marker,
	}
	mock.lockSetMarker.Lock()
	mock.calls.SetMarker = append(mock.calls.SetMarker, callInfo)
	mock.lockSetMarker.Unlock()
	mock.SetMarkerFunc(marker)
}

// SetMarkerCalls gets all the calls that were made to SetMarker.
// Check the length with:
//
//	len(mockedNameProvider.SetMarkerCalls())
func (mock *MockNameProvider) SetMarkerCalls() []struct {
	Marker ifaces.Marker
} {
	var calls []struct {
		Marker ifaces.Marker
	}
	mock.lockSetMarker.RLock()
	calls = mock.calls.SetMarker
	mock.lockSetMarker.RUnlock()
	return calls
}

// UniquePath calls UniquePathFunc.
func (mock *MockNameProvider) UniquePath(path string) structural.Ident {
	if mock.UniquePathFunc == nil {
		panic("MockNameProvider.UniquePathFunc: method is nil but NameProvider.UniquePath was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockUniquePath.Lock()
	mock.calls.UniquePath = append(mock.calls.UniquePath, callInfo)
	mock.lockUniquePath.Unlock()
	return mock.UniquePathFunc(path)
}

// UniquePathCalls gets all the calls that were made to UniquePath.
// Check the length with:
//
//	len(mockedNameProvider.UniquePathCalls())
func (mock *MockNameProvider) UniquePathCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockUniquePath.RLock()
	calls = mock.calls.UniquePath
	mock.lockUniquePath.RUnlock()
	return calls
}

// UniqueSchema calls UniqueSchemaFunc.
func (mock *MockNameProvider) UniqueSchema(name string) structural.Ident {
	if mock.UniqueSchemaFunc == nil {
		panic("MockNameProvider.UniqueSchemaFunc: method is nil but NameProvider.UniqueSchema was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockUniqueSchema.Lock()
	mock.calls.UniqueSchema = append(mock.calls.UniqueSchema, callInfo)
	mock.lockUniqueSchema.Unlock()
	return mock.UniqueSchemaFunc(name)
}

// UniqueSchemaCalls gets all the calls that were made to UniqueSchema.
// Check the length with:
//
//	len(mockedNameProvider.UniqueSchemaCalls())
func (mock *MockNameProvider) UniqueSchemaCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockUniqueSchema.RLock()
	calls = mock.calls.UniqueSchema
	mock.lockUniqueSchema.RUnlock()
	return calls
}

// Ensure that MockSchemaBuilder does implement ifaces.SchemaBuilder.
// If this is not the case, regenerate this file with mockery.
var _ ifaces.SchemaBuilder = &MockSchemaBuilder{}

// MockSchemaBuilder is a mock implementation of ifaces.SchemaBuilder.
//
//	func TestSomethingThatUsesSchemaBuilder(t *testing.T) {
//
//		// make and configure a mocked ifaces.SchemaBuilder
//		mockedSchemaBuilder := &MockSchemaBuilder{
//			GenNamedSchemasFunc: func(analyzed structural.AnalyzedSchema, seed model.TargetModel) iter.Seq[model.TargetSchema] {
//				panic("mock out the GenNamedSchemas method")
//			},
//			MapExtensionFunc: func(directive string, extension dynamic.JSON) (any, error) {
//				panic("mock out the MapExtension method")
//			},
//		}
//
//		// use mockedSchemaBuilder in code that requires ifaces.SchemaBuilder
//		// and then make assertions.
//
//	}
type MockSchemaBuilder struct {
	// GenNamedSchemasFunc mocks the GenNamedSchemas method.
	GenNamedSchemasFunc func(analyzed structural.AnalyzedSchema, seed model.TargetModel) iter.Seq[model.TargetSchema]

	// MapExtensionFunc mocks the MapExtension method.
	MapExtensionFunc func(directive string, extension dynamic.JSON) (any, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenNamedSchemas holds details about calls to the GenNamedSchemas method.
		GenNamedSchemas []struct {
			// Analyzed is the analyzed argument value.
			Analyzed structural.AnalyzedSchema
			// Seed is the seed argument value.
			Seed model.TargetModel
		}
		// MapExtension holds details about calls to the MapExtension method.
		MapExtension []struct {
			// Directive is the directive argument value.
			Directive string
			// Extension is the extension argument value.
			Extension dynamic.JSON
		}
	}
	lockGenNamedSchemas sync.RWMutex
	lockMapExtension    sync.RWMutex
}

// GenNamedSchemas calls GenNamedSchemasFunc.
func (mock *MockSchemaBuilder) GenNamedSchemas(analyzed structural.AnalyzedSchema, seed model.TargetModel) iter.Seq[model.TargetSchema] {
	if mock.GenNamedSchemasFunc == nil {
		panic("MockSchemaBuilder.GenNamedSchemasFunc: method is nil but SchemaBuilder.GenNamedSchemas was just called")
	}
	callInfo := struct {
		Analyzed structural.AnalyzedSchema
		Seed     model.TargetModel
	}{
		Analyzed: analyzed,
		Seed:     seed,
	}
	mock.lockGenNamedSchemas.Lock()
	mock.calls.GenNamedSchemas = append(mock.calls.GenNamedSchemas, callInfo)
	mock.lockGenNamedSchemas.Unlock()
	return mock.GenNamedSchemasFunc(analyzed, seed)
}

// GenNamedSchemasCalls gets all the calls that were made to GenNamedSchemas.
// Check the length with:
//
//	len(mockedSchemaBuilder.GenNamedSchemasCalls())
func (mock *MockSchemaBuilder) GenNamedSchemasCalls() []struct {
	Analyzed structural.AnalyzedSchema
	Seed     model.TargetModel
} {
	var calls []struct {
		Analyzed structural.AnalyzedSchema
		Seed     model.TargetModel
	}
	mock.lockGenNamedSchemas.RLock()
	calls = mock.calls.GenNamedSchemas
	mock.lockGenNamedSchemas.RUnlock()
	return calls
}

// MapExtension calls MapExtensionFunc.
func (mock *MockSchemaBuilder) MapExtension(directive string, extension dynamic.JSON) (any, error) {
	if mock.MapExtensionFunc == nil {
		panic("MockSchemaBuilder.MapExtensionFunc: method is nil but SchemaBuilder.MapExtension was just called")
	}
	callInfo := struct {
		Directive string
		Extension dynamic.JSON
	}{
		Directive: directive,
		Extension: extension,
	}
	mock.lockMapExtension.Lock()
	mock.calls.MapExtension = append(mock.calls.MapExtension, callInfo)
	mock.lockMapExtension.Unlock()
	return mock.MapExtensionFunc(directive, extension)
}

// MapExtensionCalls gets all the calls that were made to MapExtension.
// Check the length with:
//
//	len(mockedSchemaBuilder.MapExtensionCalls())
func (mock *MockSchemaBuilder) MapExtensionCalls() []struct {
	Directive string
	Extension dynamic.JSON
} {
	var calls []struct {
		Directive string
		Extension dynamic.JSON
	}
	mock.lockMapExtension.RLock()
	calls = mock.calls.MapExtension
	mock.lockMapExtension.RUnlock()
	return calls
}

// Ensure that MockPackageBuilder does implement ifaces.PackageBuilder.
// If this is not the case, regenerate this file with mockery.
var _ ifaces.PackageBuilder = &MockPackageBuilder{}

// MockPackageBuilder is a mock implementation of ifaces.PackageBuilder.
//
//	func TestSomethingThatUsesPackageBuilder(t *testing.T) {
//
//		// make and configure a mocked ifaces.PackageBuilder
//		mockedPackageBuilder := &MockPackageBuilder{
//			GenNamedPackagesFunc: func(analyzed structural.AnalyzedPackage, seed model.TargetPackage) iter.Seq[model.TargetPackage] {
//				panic("mock out the GenNamedPackages method")
//			},
//		}
//
//		// use mockedPackageBuilder in code that requires ifaces.PackageBuilder
//		// and then make assertions.
//
//	}
type MockPackageBuilder struct {
	// GenNamedPackagesFunc mocks the GenNamedPackages method.
	GenNamedPackagesFunc func(analyzed structural.AnalyzedPackage, seed model.TargetPackage) iter.Seq[model.TargetPackage]

	// calls tracks calls to the methods.
	calls struct {
		// GenNamedPackages holds details about calls to the GenNamedPackages method.
		GenNamedPackages []struct {
			// Analyzed is the analyzed argument value.
			Analyzed structural.AnalyzedPackage
			// Seed is the seed argument value.
			Seed model.TargetPackage
		}
	}
	lockGenNamedPackages sync.RWMutex
}

// GenNamedPackages calls GenNamedPackagesFunc.
func (mock *MockPackageBuilder) GenNamedPackages(analyzed structural.AnalyzedPackage, seed model.TargetPackage) iter.Seq[model.TargetPackage] {
	if mock.GenNamedPackagesFunc == nil {
		panic("MockPackageBuilder.GenNamedPackagesFunc: method is nil but PackageBuilder.GenNamedPackages was just called")
	}
	callInfo := struct {
		Analyzed structural.AnalyzedPackage
		Seed     model.TargetPackage
	}{
		Analyzed: analyzed,
		Seed:     seed,
	}
	mock.lockGenNamedPackages.Lock()
	mock.calls.GenNamedPackages = append(mock.calls.GenNamedPackages, callInfo)
	mock.lockGenNamedPackages.Unlock()
	return mock.GenNamedPackagesFunc(analyzed, seed)
}

// GenNamedPackagesCalls gets all the calls that were made to GenNamedPackages.
// Check the length with:
//
//	len(mockedPackageBuilder.GenNamedPackagesCalls())
func (mock *MockPackageBuilder) GenNamedPackagesCalls() []struct {
	Analyzed structural.AnalyzedPackage
	Seed     model.TargetPackage
} {
	var calls []struct {
		Analyzed structural.AnalyzedPackage
		Seed     model.TargetPackage
	}
	mock.lockGenNamedPackages.RLock()
	calls = mock.calls.GenNamedPackages
	mock.lockGenNamedPackages.RUnlock()
	return calls
}

// Ensure that MockEnumNameProvider does implement ifaces.EnumNameProvider.
// If this is not the case, regenerate this file with mockery.
var _ ifaces.EnumNameProvider = &MockEnumNameProvider{}

// MockEnumNameProvider is a mock implementation of ifaces.EnumNameProvider.
//
//	func TestSomethingThatUsesEnumNameProvider(t *testing.T) {
//
//		// make and configure a mocked ifaces.EnumNameProvider
//		mockedEnumNameProvider := &MockEnumNameProvider{
//			NameEnumValueFunc: func(index int, enumValue json.Document, analyzed structural.AnalyzedSchema) (string, error) {
//				panic("mock out the NameEnumValue method")
//			},
//		}
//
//		// use mockedEnumNameProvider in code that requires ifaces.EnumNameProvider
//		// and then make assertions.
//
//	}
type MockEnumNameProvider struct {
	// NameEnumValueFunc mocks the NameEnumValue method.
	NameEnumValueFunc func(index int, enumValue json.Document, analyzed structural.AnalyzedSchema) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// NameEnumValue holds details about calls to the NameEnumValue method.
		NameEnumValue []struct {
			// Index is the index argument value.
			Index int
			// EnumValue is the enumValue argument value.
			EnumValue json.Document
			// Analyzed is the analyzed argument value.
			Analyzed structural.AnalyzedSchema
		}
	}
	lockNameEnumValue sync.RWMutex
}

// NameEnumValue calls NameEnumValueFunc.
func (mock *MockEnumNameProvider) NameEnumValue(index int, enumValue json.Document, analyzed structural.AnalyzedSchema) (string, error) {
	if mock.NameEnumValueFunc == nil {
		panic("MockEnumNameProvider.NameEnumValueFunc: method is nil but EnumNameProvider.NameEnumValue was just called")
	}
	callInfo := struct {
		Index     int
		EnumValue json.Document
		Analyzed  structural.AnalyzedSchema
	}{
		Index:     index,
		EnumValue: enumValue,
		Analyzed:  analyzed,
	}
	mock.lockNameEnumValue.Lock()
	mock.calls.NameEnumValue = append(mock.calls.NameEnumValue, callInfo)
	mock.lockNameEnumValue.Unlock()
	return mock.NameEnumValueFunc(index, enumValue, analyzed)
}

// NameEnumValueCalls gets all the calls that were made to NameEnumValue.
// Check the length with:
//
//	len(mockedEnumNameProvider.NameEnumValueCalls())
func (mock *MockEnumNameProvider) NameEnumValueCalls() []struct {
	Index     int
	EnumValue json.Document
	Analyzed  structural.AnalyzedSchema
} {
	var calls []struct {
		Index     int
		EnumValue json.Document
		Analyzed  structural.AnalyzedSchema
	}
	mock.lockNameEnumValue.RLock()
	calls = mock.calls.NameEnumValue
	mock.lockNameEnumValue.RUnlock()
	return calls
}

// Ensure that MockAuditor does implement ifaces.Auditor.
// If this is not the case, regenerate this file with mockery.
var _ ifaces.Auditor = &MockAuditor{}

// MockAuditor is a mock implementation of ifaces.Auditor.
//
//	func TestSomethingThatUsesAuditor(t *testing.T) {
//
//		// make and configure a mocked ifaces.Auditor
//		mockedAuditor := &MockAuditor{
//			LogAuditFunc: func(analyzedSchema structural.AnalyzedSchema, auditTrailEntry structural.AuditTrailEntry)  {
//				panic("mock out the LogAudit method")
//			},
//			LogAuditPackageFunc: func(analyzedPackage structural.AnalyzedPackage, auditTrailEntry structural.AuditTrailEntry)  {
//				panic("mock out the LogAuditPackage method")
//			},
//		}
//
//		// use mockedAuditor in code that requires ifaces.Auditor
//		// and then make assertions.
//
//	}
type MockAuditor struct {
	// LogAuditFunc mocks the LogAudit method.
	LogAuditFunc func(analyzedSchema structural.AnalyzedSchema, auditTrailEntry structural.AuditTrailEntry)

	// LogAuditPackageFunc mocks the LogAuditPackage method.
	LogAuditPackageFunc func(analyzedPackage structural.AnalyzedPackage, auditTrailEntry structural.AuditTrailEntry)

	// calls tracks calls to the methods.
	calls struct {
		// LogAudit holds details about calls to the LogAudit method.
		LogAudit []struct {
			// AnalyzedSchema is the analyzedSchema argument value.
			AnalyzedSchema structural.AnalyzedSchema
			// AuditTrailEntry is the auditTrailEntry argument value.
			AuditTrailEntry structural.AuditTrailEntry
		}
		// LogAuditPackage holds details about calls to the LogAuditPackage method.
		LogAuditPackage []struct {
			// AnalyzedPackage is the analyzedPackage argument value.
			AnalyzedPackage structural.AnalyzedPackage
			// AuditTrailEntry is the auditTrailEntry argument value.
			AuditTrailEntry structural.AuditTrailEntry
		}
	}
	lockLogAudit        sync.RWMutex
	lockLogAuditPackage sync.RWMutex
}

// LogAudit calls LogAuditFunc.
func (mock *MockAuditor) LogAudit(analyzedSchema structural.AnalyzedSchema, auditTrailEntry structural.AuditTrailEntry) {
	if mock.LogAuditFunc == nil {
		panic("MockAuditor.LogAuditFunc: method is nil but Auditor.LogAudit was just called")
	}
	callInfo := struct {
		AnalyzedSchema  structural.AnalyzedSchema
		AuditTrailEntry structural.AuditTrailEntry
	}{
		AnalyzedSchema:  analyzedSchema,
		AuditTrailEntry: auditTrailEntry,
	}
	mock.lockLogAudit.Lock()
	mock.calls.LogAudit = append(mock.calls.LogAudit, callInfo)
	mock.lockLogAudit.Unlock()
	mock.LogAuditFunc(analyzedSchema, auditTrailEntry)
}

// LogAuditCalls gets all the calls that were made to LogAudit.
// Check the length with:
//
//	len(mockedAuditor.LogAuditCalls())
func (mock *MockAuditor) LogAuditCalls() []struct {
	AnalyzedSchema  structural.AnalyzedSchema
	AuditTrailEntry structural.AuditTrailEntry
} {
	var calls []struct {
		AnalyzedSchema  structural.AnalyzedSchema
		AuditTrailEntry structural.AuditTrailEntry
	}
	mock.lockLogAudit.RLock()
	calls = mock.calls.LogAudit
	mock.lockLogAudit.RUnlock()
	return calls
}

// LogAuditPackage calls LogAuditPackageFunc.
func (mock *MockAuditor) LogAuditPackage(analyzedPackage structural.AnalyzedPackage, auditTrailEntry structural.AuditTrailEntry) {
	if mock.LogAuditPackageFunc == nil {
		panic("MockAuditor.LogAuditPackageFunc: method is nil but Auditor.LogAuditPackage was just called")
	}
	callInfo := struct {
		AnalyzedPackage structural.AnalyzedPackage
		AuditTrailEntry structural.AuditTrailEntry
	}{
		AnalyzedPackage: analyzedPackage,
		AuditTrailEntry: auditTrailEntry,
	}
	mock.lockLogAuditPackage.Lock()
	mock.calls.LogAuditPackage = append(mock.calls.LogAuditPackage, callInfo)
	mock.lockLogAuditPackage.Unlock()
	mock.LogAuditPackageFunc(analyzedPackage, auditTrailEntry)
}

// LogAuditPackageCalls gets all the calls that were made to LogAuditPackage.
// Check the length with:
//
//	len(mockedAuditor.LogAuditPackageCalls())
func (mock *MockAuditor) LogAuditPackageCalls() []struct {
	AnalyzedPackage structural.AnalyzedPackage
	AuditTrailEntry structural.AuditTrailEntry
} {
	var calls []struct {
		AnalyzedPackage structural.AnalyzedPackage
		AuditTrailEntry structural.AuditTrailEntry
	}
	mock.lockLogAuditPackage.RLock()
	calls = mock.calls.LogAuditPackage
	mock.lockLogAuditPackage.RUnlock()
	return calls
}

// Ensure that MockAnnotator does implement ifaces.Annotator.
// If this is not the case, regenerate this file with mockery.
var _ ifaces.Annotator = &MockAnnotator{}

// MockAnnotator is a mock implementation of ifaces.Annotator.
//
//	func TestSomethingThatUsesAnnotator(t *testing.T) {
//
//		// make and configure a mocked ifaces.Annotator
//		mockedAnnotator := &MockAnnotator{
//			AnnotateSchemaFunc: func(analyzedSchema structural.AnalyzedSchema, metadata structural.Metadata)  {
//				panic("mock out the AnnotateSchema method")
//			},
//		}
//
//		// use mockedAnnotator in code that requires ifaces.Annotator
//		// and then make assertions.
//
//	}
type MockAnnotator struct {
	// AnnotateSchemaFunc mocks the AnnotateSchema method.
	AnnotateSchemaFunc func(analyzedSchema structural.AnalyzedSchema, metadata structural.Metadata)

	// calls tracks calls to the methods.
	calls struct {
		// AnnotateSchema holds details about calls to the AnnotateSchema method.
		AnnotateSchema []struct {
			// AnalyzedSchema is the analyzedSchema argument value.
			AnalyzedSchema structural.AnalyzedSchema
			// Metadata is the metadata argument value.
			Metadata structural.Metadata
		}
	}
	lockAnnotateSchema sync.RWMutex
}

// AnnotateSchema calls AnnotateSchemaFunc.
func (mock *MockAnnotator) AnnotateSchema(analyzedSchema structural.AnalyzedSchema, metadata structural.Metadata) {
	if mock.AnnotateSchemaFunc == nil {
		panic("MockAnnotator.AnnotateSchemaFunc: method is nil but Annotator.AnnotateSchema was just called")
	}
	callInfo := struct {
		AnalyzedSchema structural.AnalyzedSchema
		Metadata       structural.Metadata
	}{
		AnalyzedSchema: analyzedSchema,
		Metadata:       metadata,
	}
	mock.lockAnnotateSchema.Lock()
	mock.calls.AnnotateSchema = append(mock.calls.AnnotateSchema, callInfo)
	mock.lockAnnotateSchema.Unlock()
	mock.AnnotateSchemaFunc(analyzedSchema, metadata)
}

// AnnotateSchemaCalls gets all the calls that were made to AnnotateSchema.
// Check the length with:
//
//	len(mockedAnnotator.AnnotateSchemaCalls())
func (mock *MockAnnotator) AnnotateSchemaCalls() []struct {
	AnalyzedSchema structural.AnalyzedSchema
	Metadata       structural.Metadata
} {
	var calls []struct {
		AnalyzedSchema structural.AnalyzedSchema
		Metadata       structural.Metadata
	}
	mock.lockAnnotateSchema.RLock()
	calls = mock.calls.AnnotateSchema
	mock.lockAnnotateSchema.RUnlock()
	return calls
}

// Ensure that MockMarker does implement ifaces.Marker.
// If this is not the case, regenerate this file with mockery.
var _ ifaces.Marker = &MockMarker{}

// MockMarker is a mock implementation of ifaces.Marker.
//
//	func TestSomethingThatUsesMarker(t *testing.T) {
//
//		// make and configure a mocked ifaces.Marker
//		mockedMarker := &MockMarker{
//			MarkPackageFunc: func(analyzedPackage structural.AnalyzedPackage, extensions structural.Extensions)  {
//				panic("mock out the MarkPackage method")
//			},
//			MarkSchemaFunc: func(analyzedSchema structural.AnalyzedSchema, extensions structural.Extensions)  {
//				panic("mock out the MarkSchema method")
//			},
//		}
//
//		// use mockedMarker in code that requires ifaces.Marker
//		// and then make assertions.
//
//	}
type MockMarker struct {
	// MarkPackageFunc mocks the MarkPackage method.
	MarkPackageFunc func(analyzedPackage structural.AnalyzedPackage, extensions structural.Extensions)

	// MarkSchemaFunc mocks the MarkSchema method.
	MarkSchemaFunc func(analyzedSchema structural.AnalyzedSchema, extensions structural.Extensions)

	// calls tracks calls to the methods.
	calls struct {
		// MarkPackage holds details about calls to the MarkPackage method.
		MarkPackage []struct {
			// AnalyzedPackage is the analyzedPackage argument value.
			AnalyzedPackage structural.AnalyzedPackage
			// Extensions is the extensions argument value.
			Extensions structural.Extensions
		}
		// MarkSchema holds details about calls to the MarkSchema method.
		MarkSchema []struct {
			// AnalyzedSchema is the analyzedSchema argument value.
			AnalyzedSchema structural.AnalyzedSchema
			// Extensions is the extensions argument value.
			Extensions structural.Extensions
		}
	}
	lockMarkPackage sync.RWMutex
	lockMarkSchema  sync.RWMutex
}

// MarkPackage calls MarkPackageFunc.
func (mock *MockMarker) MarkPackage(analyzedPackage structural.AnalyzedPackage, extensions structural.Extensions) {
	if mock.MarkPackageFunc == nil {
		panic("MockMarker.MarkPackageFunc: method is nil but Marker.MarkPackage was just called")
	}
	callInfo := struct {
		AnalyzedPackage structural.AnalyzedPackage
		Extensions      structural.Extensions
	}{
		AnalyzedPackage: analyzedPackage,
		Extensions:      extensions,
	}
	mock.lockMarkPackage.Lock()
	mock.calls.MarkPackage = append(mock.calls.MarkPackage, callInfo)
	mock.lockMarkPackage.Unlock()
	mock.MarkPackageFunc(analyzedPackage, extensions)
}

// MarkPackageCalls gets all the calls that were made to MarkPackage.
// Check the length with:
//
//	len(mockedMarker.MarkPackageCalls())
func (mock *MockMarker) MarkPackageCalls() []struct {
	AnalyzedPackage structural.AnalyzedPackage
	Extensions      structural.Extensions
} {
	var calls []struct {
		AnalyzedPackage structural.AnalyzedPackage
		Extensions      structural.Extensions
	}
	mock.lockMarkPackage.RLock()
	calls = mock.calls.MarkPackage
	mock.lockMarkPackage.RUnlock()
	return calls
}

// MarkSchema calls MarkSchemaFunc.
func (mock *MockMarker) MarkSchema(analyzedSchema structural.AnalyzedSchema, extensions structural.Extensions) {
	if mock.MarkSchemaFunc == nil {
		panic("MockMarker.MarkSchemaFunc: method is nil but Marker.MarkSchema was just called")
	}
	callInfo := struct {
		AnalyzedSchema structural.AnalyzedSchema
		Extensions     structural.Extensions
	}{
		AnalyzedSchema: analyzedSchema,
		Extensions:     extensions,
	}
	mock.lockMarkSchema.Lock()
	mock.calls.MarkSchema = append(mock.calls.MarkSchema, callInfo)
	mock.lockMarkSchema.Unlock()
	mock.MarkSchemaFunc(analyzedSchema, extensions)
}

// MarkSchemaCalls gets all the calls that were made to MarkSchema.
// Check the length with:
//
//	len(mockedMarker.MarkSchemaCalls())
func (mock *MockMarker) MarkSchemaCalls() []struct {
	AnalyzedSchema structural.AnalyzedSchema
	Extensions     structural.Extensions
} {
	var calls []struct {
		AnalyzedSchema structural.AnalyzedSchema
		Extensions     structural.Extensions
	}
	mock.lockMarkSchema.RLock()
	calls = mock.calls.MarkSchema
	mock.lockMarkSchema.RUnlock()
	return calls
}

// Ensure that MockNameMangler does implement ifaces.NameMangler.
// If this is not the case, regenerate this file with mockery.
var _ ifaces.NameMangler = &MockNameMangler{}

// MockNameMangler is a mock implementation of ifaces.NameMangler.
//
//	func TestSomethingThatUsesNameMangler(t *testing.T) {
//
//		// make and configure a mocked ifaces.NameMangler
//		mockedNameMangler := &MockNameMangler{
//			SpellNumberFunc: func(s string) string {
//				panic("mock out the SpellNumber method")
//			},
//			ToGoFileNameFunc: func(s string) string {
//				panic("mock out the ToGoFileName method")
//			},
//			ToGoNameFunc: func(s string) string {
//				panic("mock out the ToGoName method")
//			},
//			ToGoPackageAliasFunc: func(s string, n int) string {
//				panic("mock out the ToGoPackageAlias method")
//			},
//			ToGoPackageNameFunc: func(s string) string {
//				panic("mock out the ToGoPackageName method")
//			},
//			ToGoPackagePathFunc: func(s string) string {
//				panic("mock out the ToGoPackagePath method")
//			},
//			ToGoVarNameFunc: func(s string) string {
//				panic("mock out the ToGoVarName method")
//			},
//		}
//
//		// use mockedNameMangler in code that requires ifaces.NameMangler
//		// and then make assertions.
//
//	}
type MockNameMangler struct {
	// SpellNumberFunc mocks the SpellNumber method.
	SpellNumberFunc func(s string) string

	// ToGoFileNameFunc mocks the ToGoFileName method.
	ToGoFileNameFunc func(s string) string

	// ToGoNameFunc mocks the ToGoName method.
	ToGoNameFunc func(s string) string

	// ToGoPackageAliasFunc mocks the ToGoPackageAlias method.
	ToGoPackageAliasFunc func(s string, n int) string

	// ToGoPackageNameFunc mocks the ToGoPackageName method.
	ToGoPackageNameFunc func(s string) string

	// ToGoPackagePathFunc mocks the ToGoPackagePath method.
	ToGoPackagePathFunc func(s string) string

	// ToGoVarNameFunc mocks the ToGoVarName method.
	ToGoVarNameFunc func(s string) string

	// calls tracks calls to the methods.
	calls struct {
		// SpellNumber holds details about calls to the SpellNumber method.
		SpellNumber []struct {
			// S is the s argument value.
			S string
		}
		// ToGoFileName holds details about calls to the ToGoFileName method.
		ToGoFileName []struct {
			// S is the s argument value.
			S string
		}
		// ToGoName holds details about calls to the ToGoName method.
		ToGoName []struct {
			// S is the s argument value.
			S string
		}
		// ToGoPackageAlias holds details about calls to the ToGoPackageAlias method.
		ToGoPackageAlias []struct {
			// S is the s argument value.
			S string
			// N is the n argument value.
			N int
		}
		// ToGoPackageName holds details about calls to the ToGoPackageName method.
		ToGoPackageName []struct {
			// S is the s argument value.
			S string
		}
		// ToGoPackagePath holds details about calls to the ToGoPackagePath method.
		ToGoPackagePath []struct {
			// S is the s argument value.
			S string
		}
		// ToGoVarName holds details about calls to the ToGoVarName method.
		ToGoVarName []struct {
			// S is the s argument value.
			S string
		}
	}
	lockSpellNumber      sync.RWMutex
	lockToGoFileName     sync.RWMutex
	lockToGoName         sync.RWMutex
	lockToGoPackageAlias sync.RWMutex
	lockToGoPackageName  sync.RWMutex
	lockToGoPackagePath  sync.RWMutex
	lockToGoVarName      sync.RWMutex
}

// SpellNumber calls SpellNumberFunc.
func (mock *MockNameMangler) SpellNumber(s string) string {
	if mock.SpellNumberFunc == nil {
		panic("MockNameMangler.SpellNumberFunc: method is nil but NameMangler.SpellNumber was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockSpellNumber.Lock()
	mock.calls.SpellNumber = append(mock.calls.SpellNumber, callInfo)
	mock.lockSpellNumber.Unlock()
	return mock.SpellNumberFunc(s)
}

// SpellNumberCalls gets all the calls that were made to SpellNumber.
// Check the length with:
//
//	len(mockedNameMangler.SpellNumberCalls())
func (mock *MockNameMangler) SpellNumberCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockSpellNumber.RLock()
	calls = mock.calls.SpellNumber
	mock.lockSpellNumber.RUnlock()
	return calls
}

// ToGoFileName calls ToGoFileNameFunc.
func (mock *MockNameMangler) ToGoFileName(s string) string {
	if mock.ToGoFileNameFunc == nil {
		panic("MockNameMangler.ToGoFileNameFunc: method is nil but NameMangler.ToGoFileName was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockToGoFileName.Lock()
	mock.calls.ToGoFileName = append(mock.calls.ToGoFileName, callInfo)
	mock.lockToGoFileName.Unlock()
	return mock.ToGoFileNameFunc(s)
}

// ToGoFileNameCalls gets all the calls that were made to ToGoFileName.
// Check the length with:
//
//	len(mockedNameMangler.ToGoFileNameCalls())
func (mock *MockNameMangler) ToGoFileNameCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockToGoFileName.RLock()
	calls = mock.calls.ToGoFileName
	mock.lockToGoFileName.RUnlock()
	return calls
}

// ToGoName calls ToGoNameFunc.
func (mock *MockNameMangler) ToGoName(s string) string {
	if mock.ToGoNameFunc == nil {
		panic("MockNameMangler.ToGoNameFunc: method is nil but NameMangler.ToGoName was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockToGoName.Lock()
	mock.calls.ToGoName = append(mock.calls.ToGoName, callInfo)
	mock.lockToGoName.Unlock()
	return mock.ToGoNameFunc(s)
}

// ToGoNameCalls gets all the calls that were made to ToGoName.
// Check the length with:
//
//	len(mockedNameMangler.ToGoNameCalls())
func (mock *MockNameMangler) ToGoNameCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockToGoName.RLock()
	calls = mock.calls.ToGoName
	mock.lockToGoName.RUnlock()
	return calls
}

// ToGoPackageAlias calls ToGoPackageAliasFunc.
func (mock *MockNameMangler) ToGoPackageAlias(s string, n int) string {
	if mock.ToGoPackageAliasFunc == nil {
		panic("MockNameMangler.ToGoPackageAliasFunc: method is nil but NameMangler.ToGoPackageAlias was just called")
	}
	callInfo := struct {
		S string
		N int
	}{
		S: s,
		N: n,
	}
	mock.lockToGoPackageAlias.Lock()
	mock.calls.ToGoPackageAlias = append(mock.calls.ToGoPackageAlias, callInfo)
	mock.lockToGoPackageAlias.Unlock()
	return mock.ToGoPackageAliasFunc(s, n)
}

// ToGoPackageAliasCalls gets all the calls that were made to ToGoPackageAlias.
// Check the length with:
//
//	len(mockedNameMangler.ToGoPackageAliasCalls())
func (mock *MockNameMangler) ToGoPackageAliasCalls() []struct {
	S string
	N int
} {
	var calls []struct {
		S string
		N int
	}
	mock.lockToGoPackageAlias.RLock()
	calls = mock.calls.ToGoPackageAlias
	mock.lockToGoPackageAlias.RUnlock()
	return calls
}

// ToGoPackageName calls ToGoPackageNameFunc.
func (mock *MockNameMangler) ToGoPackageName(s string) string {
	if mock.ToGoPackageNameFunc == nil {
		panic("MockNameMangler.ToGoPackageNameFunc: method is nil but NameMangler.ToGoPackageName was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockToGoPackageName.Lock()
	mock.calls.ToGoPackageName = append(mock.calls.ToGoPackageName, callInfo)
	mock.lockToGoPackageName.Unlock()
	return mock.ToGoPackageNameFunc(s)
}

// ToGoPackageNameCalls gets all the calls that were made to ToGoPackageName.
// Check the length with:
//
//	len(mockedNameMangler.ToGoPackageNameCalls())
func (mock *MockNameMangler) ToGoPackageNameCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockToGoPackageName.RLock()
	calls = mock.calls.ToGoPackageName
	mock.lockToGoPackageName.RUnlock()
	return calls
}

// ToGoPackagePath calls ToGoPackagePathFunc.
func (mock *MockNameMangler) ToGoPackagePath(s string) string {
	if mock.ToGoPackagePathFunc == nil {
		panic("MockNameMangler.ToGoPackagePathFunc: method is nil but NameMangler.ToGoPackagePath was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockToGoPackagePath.Lock()
	mock.calls.ToGoPackagePath = append(mock.calls.ToGoPackagePath, callInfo)
	mock.lockToGoPackagePath.Unlock()
	return mock.ToGoPackagePathFunc(s)
}

// ToGoPackagePathCalls gets all the calls that were made to ToGoPackagePath.
// Check the length with:
//
//	len(mockedNameMangler.ToGoPackagePathCalls())
func (mock *MockNameMangler) ToGoPackagePathCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockToGoPackagePath.RLock()
	calls = mock.calls.ToGoPackagePath
	mock.lockToGoPackagePath.RUnlock()
	return calls
}

// ToGoVarName calls ToGoVarNameFunc.
func (mock *MockNameMangler) ToGoVarName(s string) string {
	if mock.ToGoVarNameFunc == nil {
		panic("MockNameMangler.ToGoVarNameFunc: method is nil but NameMangler.ToGoVarName was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockToGoVarName.Lock()
	mock.calls.ToGoVarName = append(mock.calls.ToGoVarName, callInfo)
	mock.lockToGoVarName.Unlock()
	return mock.ToGoVarNameFunc(s)
}

// ToGoVarNameCalls gets all the calls that were made to ToGoVarName.
// Check the length with:
//
//	len(mockedNameMangler.ToGoVarNameCalls())
func (mock *MockNameMangler) ToGoVarNameCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockToGoVarName.RLock()
	calls = mock.calls.ToGoVarName
	mock.lockToGoVarName.RUnlock()
	return calls
}
