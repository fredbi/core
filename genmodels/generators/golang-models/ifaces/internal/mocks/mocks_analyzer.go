// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mocks

import (
	"iter"
	"sync"

	"github.com/fredbi/core/jsonschema"
	"github.com/fredbi/core/jsonschema/analyzers"
	"github.com/fredbi/core/jsonschema/analyzers/structural"
)

// Ensure that MockAnalyzer does implement structural.Analyzer.
// If this is not the case, regenerate this file with mockery.
var _ structural.Analyzer = &MockAnalyzer{}

// MockAnalyzer is a mock implementation of structural.Analyzer.
//
//	func TestSomethingThatUsesAnalyzer(t *testing.T) {
//
//		// make and configure a mocked structural.Analyzer
//		mockedAnalyzer := &MockAnalyzer{
//			AnalyzeFunc: func(schema jsonschema.Schema) error {
//				panic("mock out the Analyze method")
//			},
//			AnalyzeCollectionFunc: func(collection jsonschema.Collection) error {
//				panic("mock out the AnalyzeCollection method")
//			},
//			AnalyzedSchemasFunc: func(filters ...structural.Filter) iter.Seq[structural.AnalyzedSchema] {
//				panic("mock out the AnalyzedSchemas method")
//			},
//			AnnotateSchemaFunc: func(analyzedSchema structural.AnalyzedSchema, metadata structural.Metadata)  {
//				panic("mock out the AnnotateSchema method")
//			},
//			BundleFunc: func() (structural.Analyzer, error) {
//				panic("mock out the Bundle method")
//			},
//			LenFunc: func() int {
//				panic("mock out the Len method")
//			},
//			LogAuditFunc: func(analyzedSchema structural.AnalyzedSchema, auditTrailEntry structural.AuditTrailEntry)  {
//				panic("mock out the LogAudit method")
//			},
//			LogAuditPackageFunc: func(analyzedPackage structural.AnalyzedPackage, auditTrailEntry structural.AuditTrailEntry)  {
//				panic("mock out the LogAuditPackage method")
//			},
//			MarkPackageFunc: func(analyzedPackage structural.AnalyzedPackage, extensions structural.Extensions)  {
//				panic("mock out the MarkPackage method")
//			},
//			MarkSchemaFunc: func(analyzedSchema structural.AnalyzedSchema, extensions structural.Extensions)  {
//				panic("mock out the MarkSchema method")
//			},
//			NamespacesFunc: func(filters ...structural.Filter) iter.Seq[string] {
//				panic("mock out the Namespaces method")
//			},
//			PackagesFunc: func(filters ...structural.Filter) iter.Seq[structural.AnalyzedPackage] {
//				panic("mock out the Packages method")
//			},
//			SchemaByIDFunc: func(uniqueID analyzers.UniqueID) (structural.AnalyzedSchema, bool) {
//				panic("mock out the SchemaByID method")
//			},
//		}
//
//		// use mockedAnalyzer in code that requires structural.Analyzer
//		// and then make assertions.
//
//	}
type MockAnalyzer struct {
	// AnalyzeFunc mocks the Analyze method.
	AnalyzeFunc func(schema jsonschema.Schema) error

	// AnalyzeCollectionFunc mocks the AnalyzeCollection method.
	AnalyzeCollectionFunc func(collection jsonschema.Collection) error

	// AnalyzedSchemasFunc mocks the AnalyzedSchemas method.
	AnalyzedSchemasFunc func(filters ...structural.Filter) iter.Seq[structural.AnalyzedSchema]

	// AnnotateSchemaFunc mocks the AnnotateSchema method.
	AnnotateSchemaFunc func(analyzedSchema structural.AnalyzedSchema, metadata structural.Metadata)

	// BundleFunc mocks the Bundle method.
	BundleFunc func() (structural.Analyzer, error)

	// LenFunc mocks the Len method.
	LenFunc func() int

	// LogAuditFunc mocks the LogAudit method.
	LogAuditFunc func(analyzedSchema structural.AnalyzedSchema, auditTrailEntry structural.AuditTrailEntry)

	// LogAuditPackageFunc mocks the LogAuditPackage method.
	LogAuditPackageFunc func(analyzedPackage structural.AnalyzedPackage, auditTrailEntry structural.AuditTrailEntry)

	// MarkPackageFunc mocks the MarkPackage method.
	MarkPackageFunc func(analyzedPackage structural.AnalyzedPackage, extensions structural.Extensions)

	// MarkSchemaFunc mocks the MarkSchema method.
	MarkSchemaFunc func(analyzedSchema structural.AnalyzedSchema, extensions structural.Extensions)

	// NamespacesFunc mocks the Namespaces method.
	NamespacesFunc func(filters ...structural.Filter) iter.Seq[string]

	// PackagesFunc mocks the Packages method.
	PackagesFunc func(filters ...structural.Filter) iter.Seq[structural.AnalyzedPackage]

	// SchemaByIDFunc mocks the SchemaByID method.
	SchemaByIDFunc func(uniqueID analyzers.UniqueID) (structural.AnalyzedSchema, bool)

	// calls tracks calls to the methods.
	calls struct {
		// Analyze holds details about calls to the Analyze method.
		Analyze []struct {
			// Schema is the schema argument value.
			Schema jsonschema.Schema
		}
		// AnalyzeCollection holds details about calls to the AnalyzeCollection method.
		AnalyzeCollection []struct {
			// Collection is the collection argument value.
			Collection jsonschema.Collection
		}
		// AnalyzedSchemas holds details about calls to the AnalyzedSchemas method.
		AnalyzedSchemas []struct {
			// Filters is the filters argument value.
			Filters []structural.Filter
		}
		// AnnotateSchema holds details about calls to the AnnotateSchema method.
		AnnotateSchema []struct {
			// AnalyzedSchema is the analyzedSchema argument value.
			AnalyzedSchema structural.AnalyzedSchema
			// Metadata is the metadata argument value.
			Metadata structural.Metadata
		}
		// Bundle holds details about calls to the Bundle method.
		Bundle []struct {
		}
		// Len holds details about calls to the Len method.
		Len []struct {
		}
		// LogAudit holds details about calls to the LogAudit method.
		LogAudit []struct {
			// AnalyzedSchema is the analyzedSchema argument value.
			AnalyzedSchema structural.AnalyzedSchema
			// AuditTrailEntry is the auditTrailEntry argument value.
			AuditTrailEntry structural.AuditTrailEntry
		}
		// LogAuditPackage holds details about calls to the LogAuditPackage method.
		LogAuditPackage []struct {
			// AnalyzedPackage is the analyzedPackage argument value.
			AnalyzedPackage structural.AnalyzedPackage
			// AuditTrailEntry is the auditTrailEntry argument value.
			AuditTrailEntry structural.AuditTrailEntry
		}
		// MarkPackage holds details about calls to the MarkPackage method.
		MarkPackage []struct {
			// AnalyzedPackage is the analyzedPackage argument value.
			AnalyzedPackage structural.AnalyzedPackage
			// Extensions is the extensions argument value.
			Extensions structural.Extensions
		}
		// MarkSchema holds details about calls to the MarkSchema method.
		MarkSchema []struct {
			// AnalyzedSchema is the analyzedSchema argument value.
			AnalyzedSchema structural.AnalyzedSchema
			// Extensions is the extensions argument value.
			Extensions structural.Extensions
		}
		// Namespaces holds details about calls to the Namespaces method.
		Namespaces []struct {
			// Filters is the filters argument value.
			Filters []structural.Filter
		}
		// Packages holds details about calls to the Packages method.
		Packages []struct {
			// Filters is the filters argument value.
			Filters []structural.Filter
		}
		// SchemaByID holds details about calls to the SchemaByID method.
		SchemaByID []struct {
			// UniqueID is the uniqueID argument value.
			UniqueID analyzers.UniqueID
		}
	}
	lockAnalyze           sync.RWMutex
	lockAnalyzeCollection sync.RWMutex
	lockAnalyzedSchemas   sync.RWMutex
	lockAnnotateSchema    sync.RWMutex
	lockBundle            sync.RWMutex
	lockLen               sync.RWMutex
	lockLogAudit          sync.RWMutex
	lockLogAuditPackage   sync.RWMutex
	lockMarkPackage       sync.RWMutex
	lockMarkSchema        sync.RWMutex
	lockNamespaces        sync.RWMutex
	lockPackages          sync.RWMutex
	lockSchemaByID        sync.RWMutex
}

// Analyze calls AnalyzeFunc.
func (mock *MockAnalyzer) Analyze(schema jsonschema.Schema) error {
	if mock.AnalyzeFunc == nil {
		panic("MockAnalyzer.AnalyzeFunc: method is nil but Analyzer.Analyze was just called")
	}
	callInfo := struct {
		Schema jsonschema.Schema
	}{
		Schema: schema,
	}
	mock.lockAnalyze.Lock()
	mock.calls.Analyze = append(mock.calls.Analyze, callInfo)
	mock.lockAnalyze.Unlock()
	return mock.AnalyzeFunc(schema)
}

// AnalyzeCalls gets all the calls that were made to Analyze.
// Check the length with:
//
//	len(mockedAnalyzer.AnalyzeCalls())
func (mock *MockAnalyzer) AnalyzeCalls() []struct {
	Schema jsonschema.Schema
} {
	var calls []struct {
		Schema jsonschema.Schema
	}
	mock.lockAnalyze.RLock()
	calls = mock.calls.Analyze
	mock.lockAnalyze.RUnlock()
	return calls
}

// AnalyzeCollection calls AnalyzeCollectionFunc.
func (mock *MockAnalyzer) AnalyzeCollection(collection jsonschema.Collection) error {
	if mock.AnalyzeCollectionFunc == nil {
		panic("MockAnalyzer.AnalyzeCollectionFunc: method is nil but Analyzer.AnalyzeCollection was just called")
	}
	callInfo := struct {
		Collection jsonschema.Collection
	}{
		Collection: collection,
	}
	mock.lockAnalyzeCollection.Lock()
	mock.calls.AnalyzeCollection = append(mock.calls.AnalyzeCollection, callInfo)
	mock.lockAnalyzeCollection.Unlock()
	return mock.AnalyzeCollectionFunc(collection)
}

// AnalyzeCollectionCalls gets all the calls that were made to AnalyzeCollection.
// Check the length with:
//
//	len(mockedAnalyzer.AnalyzeCollectionCalls())
func (mock *MockAnalyzer) AnalyzeCollectionCalls() []struct {
	Collection jsonschema.Collection
} {
	var calls []struct {
		Collection jsonschema.Collection
	}
	mock.lockAnalyzeCollection.RLock()
	calls = mock.calls.AnalyzeCollection
	mock.lockAnalyzeCollection.RUnlock()
	return calls
}

// AnalyzedSchemas calls AnalyzedSchemasFunc.
func (mock *MockAnalyzer) AnalyzedSchemas(filters ...structural.Filter) iter.Seq[structural.AnalyzedSchema] {
	if mock.AnalyzedSchemasFunc == nil {
		panic("MockAnalyzer.AnalyzedSchemasFunc: method is nil but Analyzer.AnalyzedSchemas was just called")
	}
	callInfo := struct {
		Filters []structural.Filter
	}{
		Filters: filters,
	}
	mock.lockAnalyzedSchemas.Lock()
	mock.calls.AnalyzedSchemas = append(mock.calls.AnalyzedSchemas, callInfo)
	mock.lockAnalyzedSchemas.Unlock()
	return mock.AnalyzedSchemasFunc(filters...)
}

// AnalyzedSchemasCalls gets all the calls that were made to AnalyzedSchemas.
// Check the length with:
//
//	len(mockedAnalyzer.AnalyzedSchemasCalls())
func (mock *MockAnalyzer) AnalyzedSchemasCalls() []struct {
	Filters []structural.Filter
} {
	var calls []struct {
		Filters []structural.Filter
	}
	mock.lockAnalyzedSchemas.RLock()
	calls = mock.calls.AnalyzedSchemas
	mock.lockAnalyzedSchemas.RUnlock()
	return calls
}

// AnnotateSchema calls AnnotateSchemaFunc.
func (mock *MockAnalyzer) AnnotateSchema(analyzedSchema structural.AnalyzedSchema, metadata structural.Metadata) {
	if mock.AnnotateSchemaFunc == nil {
		panic("MockAnalyzer.AnnotateSchemaFunc: method is nil but Analyzer.AnnotateSchema was just called")
	}
	callInfo := struct {
		AnalyzedSchema structural.AnalyzedSchema
		Metadata       structural.Metadata
	}{
		AnalyzedSchema: analyzedSchema,
		Metadata:       metadata,
	}
	mock.lockAnnotateSchema.Lock()
	mock.calls.AnnotateSchema = append(mock.calls.AnnotateSchema, callInfo)
	mock.lockAnnotateSchema.Unlock()
	mock.AnnotateSchemaFunc(analyzedSchema, metadata)
}

// AnnotateSchemaCalls gets all the calls that were made to AnnotateSchema.
// Check the length with:
//
//	len(mockedAnalyzer.AnnotateSchemaCalls())
func (mock *MockAnalyzer) AnnotateSchemaCalls() []struct {
	AnalyzedSchema structural.AnalyzedSchema
	Metadata       structural.Metadata
} {
	var calls []struct {
		AnalyzedSchema structural.AnalyzedSchema
		Metadata       structural.Metadata
	}
	mock.lockAnnotateSchema.RLock()
	calls = mock.calls.AnnotateSchema
	mock.lockAnnotateSchema.RUnlock()
	return calls
}

// Bundle calls BundleFunc.
func (mock *MockAnalyzer) Bundle() (structural.Analyzer, error) {
	if mock.BundleFunc == nil {
		panic("MockAnalyzer.BundleFunc: method is nil but Analyzer.Bundle was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBundle.Lock()
	mock.calls.Bundle = append(mock.calls.Bundle, callInfo)
	mock.lockBundle.Unlock()
	return mock.BundleFunc()
}

// BundleCalls gets all the calls that were made to Bundle.
// Check the length with:
//
//	len(mockedAnalyzer.BundleCalls())
func (mock *MockAnalyzer) BundleCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBundle.RLock()
	calls = mock.calls.Bundle
	mock.lockBundle.RUnlock()
	return calls
}

// Len calls LenFunc.
func (mock *MockAnalyzer) Len() int {
	if mock.LenFunc == nil {
		panic("MockAnalyzer.LenFunc: method is nil but Analyzer.Len was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLen.Lock()
	mock.calls.Len = append(mock.calls.Len, callInfo)
	mock.lockLen.Unlock()
	return mock.LenFunc()
}

// LenCalls gets all the calls that were made to Len.
// Check the length with:
//
//	len(mockedAnalyzer.LenCalls())
func (mock *MockAnalyzer) LenCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLen.RLock()
	calls = mock.calls.Len
	mock.lockLen.RUnlock()
	return calls
}

// LogAudit calls LogAuditFunc.
func (mock *MockAnalyzer) LogAudit(analyzedSchema structural.AnalyzedSchema, auditTrailEntry structural.AuditTrailEntry) {
	if mock.LogAuditFunc == nil {
		panic("MockAnalyzer.LogAuditFunc: method is nil but Analyzer.LogAudit was just called")
	}
	callInfo := struct {
		AnalyzedSchema  structural.AnalyzedSchema
		AuditTrailEntry structural.AuditTrailEntry
	}{
		AnalyzedSchema:  analyzedSchema,
		AuditTrailEntry: auditTrailEntry,
	}
	mock.lockLogAudit.Lock()
	mock.calls.LogAudit = append(mock.calls.LogAudit, callInfo)
	mock.lockLogAudit.Unlock()
	mock.LogAuditFunc(analyzedSchema, auditTrailEntry)
}

// LogAuditCalls gets all the calls that were made to LogAudit.
// Check the length with:
//
//	len(mockedAnalyzer.LogAuditCalls())
func (mock *MockAnalyzer) LogAuditCalls() []struct {
	AnalyzedSchema  structural.AnalyzedSchema
	AuditTrailEntry structural.AuditTrailEntry
} {
	var calls []struct {
		AnalyzedSchema  structural.AnalyzedSchema
		AuditTrailEntry structural.AuditTrailEntry
	}
	mock.lockLogAudit.RLock()
	calls = mock.calls.LogAudit
	mock.lockLogAudit.RUnlock()
	return calls
}

// LogAuditPackage calls LogAuditPackageFunc.
func (mock *MockAnalyzer) LogAuditPackage(analyzedPackage structural.AnalyzedPackage, auditTrailEntry structural.AuditTrailEntry) {
	if mock.LogAuditPackageFunc == nil {
		panic("MockAnalyzer.LogAuditPackageFunc: method is nil but Analyzer.LogAuditPackage was just called")
	}
	callInfo := struct {
		AnalyzedPackage structural.AnalyzedPackage
		AuditTrailEntry structural.AuditTrailEntry
	}{
		AnalyzedPackage: analyzedPackage,
		AuditTrailEntry: auditTrailEntry,
	}
	mock.lockLogAuditPackage.Lock()
	mock.calls.LogAuditPackage = append(mock.calls.LogAuditPackage, callInfo)
	mock.lockLogAuditPackage.Unlock()
	mock.LogAuditPackageFunc(analyzedPackage, auditTrailEntry)
}

// LogAuditPackageCalls gets all the calls that were made to LogAuditPackage.
// Check the length with:
//
//	len(mockedAnalyzer.LogAuditPackageCalls())
func (mock *MockAnalyzer) LogAuditPackageCalls() []struct {
	AnalyzedPackage structural.AnalyzedPackage
	AuditTrailEntry structural.AuditTrailEntry
} {
	var calls []struct {
		AnalyzedPackage structural.AnalyzedPackage
		AuditTrailEntry structural.AuditTrailEntry
	}
	mock.lockLogAuditPackage.RLock()
	calls = mock.calls.LogAuditPackage
	mock.lockLogAuditPackage.RUnlock()
	return calls
}

// MarkPackage calls MarkPackageFunc.
func (mock *MockAnalyzer) MarkPackage(analyzedPackage structural.AnalyzedPackage, extensions structural.Extensions) {
	if mock.MarkPackageFunc == nil {
		panic("MockAnalyzer.MarkPackageFunc: method is nil but Analyzer.MarkPackage was just called")
	}
	callInfo := struct {
		AnalyzedPackage structural.AnalyzedPackage
		Extensions      structural.Extensions
	}{
		AnalyzedPackage: analyzedPackage,
		Extensions:      extensions,
	}
	mock.lockMarkPackage.Lock()
	mock.calls.MarkPackage = append(mock.calls.MarkPackage, callInfo)
	mock.lockMarkPackage.Unlock()
	mock.MarkPackageFunc(analyzedPackage, extensions)
}

// MarkPackageCalls gets all the calls that were made to MarkPackage.
// Check the length with:
//
//	len(mockedAnalyzer.MarkPackageCalls())
func (mock *MockAnalyzer) MarkPackageCalls() []struct {
	AnalyzedPackage structural.AnalyzedPackage
	Extensions      structural.Extensions
} {
	var calls []struct {
		AnalyzedPackage structural.AnalyzedPackage
		Extensions      structural.Extensions
	}
	mock.lockMarkPackage.RLock()
	calls = mock.calls.MarkPackage
	mock.lockMarkPackage.RUnlock()
	return calls
}

// MarkSchema calls MarkSchemaFunc.
func (mock *MockAnalyzer) MarkSchema(analyzedSchema structural.AnalyzedSchema, extensions structural.Extensions) {
	if mock.MarkSchemaFunc == nil {
		panic("MockAnalyzer.MarkSchemaFunc: method is nil but Analyzer.MarkSchema was just called")
	}
	callInfo := struct {
		AnalyzedSchema structural.AnalyzedSchema
		Extensions     structural.Extensions
	}{
		AnalyzedSchema: analyzedSchema,
		Extensions:     extensions,
	}
	mock.lockMarkSchema.Lock()
	mock.calls.MarkSchema = append(mock.calls.MarkSchema, callInfo)
	mock.lockMarkSchema.Unlock()
	mock.MarkSchemaFunc(analyzedSchema, extensions)
}

// MarkSchemaCalls gets all the calls that were made to MarkSchema.
// Check the length with:
//
//	len(mockedAnalyzer.MarkSchemaCalls())
func (mock *MockAnalyzer) MarkSchemaCalls() []struct {
	AnalyzedSchema structural.AnalyzedSchema
	Extensions     structural.Extensions
} {
	var calls []struct {
		AnalyzedSchema structural.AnalyzedSchema
		Extensions     structural.Extensions
	}
	mock.lockMarkSchema.RLock()
	calls = mock.calls.MarkSchema
	mock.lockMarkSchema.RUnlock()
	return calls
}

// Namespaces calls NamespacesFunc.
func (mock *MockAnalyzer) Namespaces(filters ...structural.Filter) iter.Seq[string] {
	if mock.NamespacesFunc == nil {
		panic("MockAnalyzer.NamespacesFunc: method is nil but Analyzer.Namespaces was just called")
	}
	callInfo := struct {
		Filters []structural.Filter
	}{
		Filters: filters,
	}
	mock.lockNamespaces.Lock()
	mock.calls.Namespaces = append(mock.calls.Namespaces, callInfo)
	mock.lockNamespaces.Unlock()
	return mock.NamespacesFunc(filters...)
}

// NamespacesCalls gets all the calls that were made to Namespaces.
// Check the length with:
//
//	len(mockedAnalyzer.NamespacesCalls())
func (mock *MockAnalyzer) NamespacesCalls() []struct {
	Filters []structural.Filter
} {
	var calls []struct {
		Filters []structural.Filter
	}
	mock.lockNamespaces.RLock()
	calls = mock.calls.Namespaces
	mock.lockNamespaces.RUnlock()
	return calls
}

// Packages calls PackagesFunc.
func (mock *MockAnalyzer) Packages(filters ...structural.Filter) iter.Seq[structural.AnalyzedPackage] {
	if mock.PackagesFunc == nil {
		panic("MockAnalyzer.PackagesFunc: method is nil but Analyzer.Packages was just called")
	}
	callInfo := struct {
		Filters []structural.Filter
	}{
		Filters: filters,
	}
	mock.lockPackages.Lock()
	mock.calls.Packages = append(mock.calls.Packages, callInfo)
	mock.lockPackages.Unlock()
	return mock.PackagesFunc(filters...)
}

// PackagesCalls gets all the calls that were made to Packages.
// Check the length with:
//
//	len(mockedAnalyzer.PackagesCalls())
func (mock *MockAnalyzer) PackagesCalls() []struct {
	Filters []structural.Filter
} {
	var calls []struct {
		Filters []structural.Filter
	}
	mock.lockPackages.RLock()
	calls = mock.calls.Packages
	mock.lockPackages.RUnlock()
	return calls
}

// SchemaByID calls SchemaByIDFunc.
func (mock *MockAnalyzer) SchemaByID(uniqueID analyzers.UniqueID) (structural.AnalyzedSchema, bool) {
	if mock.SchemaByIDFunc == nil {
		panic("MockAnalyzer.SchemaByIDFunc: method is nil but Analyzer.SchemaByID was just called")
	}
	callInfo := struct {
		UniqueID analyzers.UniqueID
	}{
		UniqueID: uniqueID,
	}
	mock.lockSchemaByID.Lock()
	mock.calls.SchemaByID = append(mock.calls.SchemaByID, callInfo)
	mock.lockSchemaByID.Unlock()
	return mock.SchemaByIDFunc(uniqueID)
}

// SchemaByIDCalls gets all the calls that were made to SchemaByID.
// Check the length with:
//
//	len(mockedAnalyzer.SchemaByIDCalls())
func (mock *MockAnalyzer) SchemaByIDCalls() []struct {
	UniqueID analyzers.UniqueID
} {
	var calls []struct {
		UniqueID analyzers.UniqueID
	}
	mock.lockSchemaByID.RLock()
	calls = mock.calls.SchemaByID
	mock.lockSchemaByID.RUnlock()
	return calls
}

// Ensure that MockNamespace does implement structural.Namespace.
// If this is not the case, regenerate this file with mockery.
var _ structural.Namespace = &MockNamespace{}

// MockNamespace is a mock implementation of structural.Namespace.
//
//	func TestSomethingThatUsesNamespace(t *testing.T) {
//
//		// make and configure a mocked structural.Namespace
//		mockedNamespace := &MockNamespace{
//			CheckNoConflictFunc: func(ident structural.Ident) bool {
//				panic("mock out the CheckNoConflict method")
//			},
//			MetaFunc: func(ident structural.Ident) (structural.ConflictMeta, bool) {
//				panic("mock out the Meta method")
//			},
//			PathFunc: func() string {
//				panic("mock out the Path method")
//			},
//		}
//
//		// use mockedNamespace in code that requires structural.Namespace
//		// and then make assertions.
//
//	}
type MockNamespace struct {
	// CheckNoConflictFunc mocks the CheckNoConflict method.
	CheckNoConflictFunc func(ident structural.Ident) bool

	// MetaFunc mocks the Meta method.
	MetaFunc func(ident structural.Ident) (structural.ConflictMeta, bool)

	// PathFunc mocks the Path method.
	PathFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// CheckNoConflict holds details about calls to the CheckNoConflict method.
		CheckNoConflict []struct {
			// Ident is the ident argument value.
			Ident structural.Ident
		}
		// Meta holds details about calls to the Meta method.
		Meta []struct {
			// Ident is the ident argument value.
			Ident structural.Ident
		}
		// Path holds details about calls to the Path method.
		Path []struct {
		}
	}
	lockCheckNoConflict sync.RWMutex
	lockMeta            sync.RWMutex
	lockPath            sync.RWMutex
}

// CheckNoConflict calls CheckNoConflictFunc.
func (mock *MockNamespace) CheckNoConflict(ident structural.Ident) bool {
	if mock.CheckNoConflictFunc == nil {
		panic("MockNamespace.CheckNoConflictFunc: method is nil but Namespace.CheckNoConflict was just called")
	}
	callInfo := struct {
		Ident structural.Ident
	}{
		Ident: ident,
	}
	mock.lockCheckNoConflict.Lock()
	mock.calls.CheckNoConflict = append(mock.calls.CheckNoConflict, callInfo)
	mock.lockCheckNoConflict.Unlock()
	return mock.CheckNoConflictFunc(ident)
}

// CheckNoConflictCalls gets all the calls that were made to CheckNoConflict.
// Check the length with:
//
//	len(mockedNamespace.CheckNoConflictCalls())
func (mock *MockNamespace) CheckNoConflictCalls() []struct {
	Ident structural.Ident
} {
	var calls []struct {
		Ident structural.Ident
	}
	mock.lockCheckNoConflict.RLock()
	calls = mock.calls.CheckNoConflict
	mock.lockCheckNoConflict.RUnlock()
	return calls
}

// Meta calls MetaFunc.
func (mock *MockNamespace) Meta(ident structural.Ident) (structural.ConflictMeta, bool) {
	if mock.MetaFunc == nil {
		panic("MockNamespace.MetaFunc: method is nil but Namespace.Meta was just called")
	}
	callInfo := struct {
		Ident structural.Ident
	}{
		Ident: ident,
	}
	mock.lockMeta.Lock()
	mock.calls.Meta = append(mock.calls.Meta, callInfo)
	mock.lockMeta.Unlock()
	return mock.MetaFunc(ident)
}

// MetaCalls gets all the calls that were made to Meta.
// Check the length with:
//
//	len(mockedNamespace.MetaCalls())
func (mock *MockNamespace) MetaCalls() []struct {
	Ident structural.Ident
} {
	var calls []struct {
		Ident structural.Ident
	}
	mock.lockMeta.RLock()
	calls = mock.calls.Meta
	mock.lockMeta.RUnlock()
	return calls
}

// Path calls PathFunc.
func (mock *MockNamespace) Path() string {
	if mock.PathFunc == nil {
		panic("MockNamespace.PathFunc: method is nil but Namespace.Path was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPath.Lock()
	mock.calls.Path = append(mock.calls.Path, callInfo)
	mock.lockPath.Unlock()
	return mock.PathFunc()
}

// PathCalls gets all the calls that were made to Path.
// Check the length with:
//
//	len(mockedNamespace.PathCalls())
func (mock *MockNamespace) PathCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPath.RLock()
	calls = mock.calls.Path
	mock.lockPath.RUnlock()
	return calls
}

// Ensure that MockBacktrackableNamespace does implement structural.BacktrackableNamespace.
// If this is not the case, regenerate this file with mockery.
var _ structural.BacktrackableNamespace = &MockBacktrackableNamespace{}

// MockBacktrackableNamespace is a mock implementation of structural.BacktrackableNamespace.
//
//	func TestSomethingThatUsesBacktrackableNamespace(t *testing.T) {
//
//		// make and configure a mocked structural.BacktrackableNamespace
//		mockedBacktrackableNamespace := &MockBacktrackableNamespace{
//			BacktrackFunc: func(resolved structural.ConflictMeta) bool {
//				panic("mock out the Backtrack method")
//			},
//			CheckNoConflictFunc: func(ident structural.Ident) bool {
//				panic("mock out the CheckNoConflict method")
//			},
//			MetaFunc: func(ident structural.Ident) (structural.ConflictMeta, bool) {
//				panic("mock out the Meta method")
//			},
//			PathFunc: func() string {
//				panic("mock out the Path method")
//			},
//		}
//
//		// use mockedBacktrackableNamespace in code that requires structural.BacktrackableNamespace
//		// and then make assertions.
//
//	}
type MockBacktrackableNamespace struct {
	// BacktrackFunc mocks the Backtrack method.
	BacktrackFunc func(resolved structural.ConflictMeta) bool

	// CheckNoConflictFunc mocks the CheckNoConflict method.
	CheckNoConflictFunc func(ident structural.Ident) bool

	// MetaFunc mocks the Meta method.
	MetaFunc func(ident structural.Ident) (structural.ConflictMeta, bool)

	// PathFunc mocks the Path method.
	PathFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Backtrack holds details about calls to the Backtrack method.
		Backtrack []struct {
			// Resolved is the resolved argument value.
			Resolved structural.ConflictMeta
		}
		// CheckNoConflict holds details about calls to the CheckNoConflict method.
		CheckNoConflict []struct {
			// Ident is the ident argument value.
			Ident structural.Ident
		}
		// Meta holds details about calls to the Meta method.
		Meta []struct {
			// Ident is the ident argument value.
			Ident structural.Ident
		}
		// Path holds details about calls to the Path method.
		Path []struct {
		}
	}
	lockBacktrack       sync.RWMutex
	lockCheckNoConflict sync.RWMutex
	lockMeta            sync.RWMutex
	lockPath            sync.RWMutex
}

// Backtrack calls BacktrackFunc.
func (mock *MockBacktrackableNamespace) Backtrack(resolved structural.ConflictMeta) bool {
	if mock.BacktrackFunc == nil {
		panic("MockBacktrackableNamespace.BacktrackFunc: method is nil but BacktrackableNamespace.Backtrack was just called")
	}
	callInfo := struct {
		Resolved structural.ConflictMeta
	}{
		Resolved: resolved,
	}
	mock.lockBacktrack.Lock()
	mock.calls.Backtrack = append(mock.calls.Backtrack, callInfo)
	mock.lockBacktrack.Unlock()
	return mock.BacktrackFunc(resolved)
}

// BacktrackCalls gets all the calls that were made to Backtrack.
// Check the length with:
//
//	len(mockedBacktrackableNamespace.BacktrackCalls())
func (mock *MockBacktrackableNamespace) BacktrackCalls() []struct {
	Resolved structural.ConflictMeta
} {
	var calls []struct {
		Resolved structural.ConflictMeta
	}
	mock.lockBacktrack.RLock()
	calls = mock.calls.Backtrack
	mock.lockBacktrack.RUnlock()
	return calls
}

// CheckNoConflict calls CheckNoConflictFunc.
func (mock *MockBacktrackableNamespace) CheckNoConflict(ident structural.Ident) bool {
	if mock.CheckNoConflictFunc == nil {
		panic("MockBacktrackableNamespace.CheckNoConflictFunc: method is nil but BacktrackableNamespace.CheckNoConflict was just called")
	}
	callInfo := struct {
		Ident structural.Ident
	}{
		Ident: ident,
	}
	mock.lockCheckNoConflict.Lock()
	mock.calls.CheckNoConflict = append(mock.calls.CheckNoConflict, callInfo)
	mock.lockCheckNoConflict.Unlock()
	return mock.CheckNoConflictFunc(ident)
}

// CheckNoConflictCalls gets all the calls that were made to CheckNoConflict.
// Check the length with:
//
//	len(mockedBacktrackableNamespace.CheckNoConflictCalls())
func (mock *MockBacktrackableNamespace) CheckNoConflictCalls() []struct {
	Ident structural.Ident
} {
	var calls []struct {
		Ident structural.Ident
	}
	mock.lockCheckNoConflict.RLock()
	calls = mock.calls.CheckNoConflict
	mock.lockCheckNoConflict.RUnlock()
	return calls
}

// Meta calls MetaFunc.
func (mock *MockBacktrackableNamespace) Meta(ident structural.Ident) (structural.ConflictMeta, bool) {
	if mock.MetaFunc == nil {
		panic("MockBacktrackableNamespace.MetaFunc: method is nil but BacktrackableNamespace.Meta was just called")
	}
	callInfo := struct {
		Ident structural.Ident
	}{
		Ident: ident,
	}
	mock.lockMeta.Lock()
	mock.calls.Meta = append(mock.calls.Meta, callInfo)
	mock.lockMeta.Unlock()
	return mock.MetaFunc(ident)
}

// MetaCalls gets all the calls that were made to Meta.
// Check the length with:
//
//	len(mockedBacktrackableNamespace.MetaCalls())
func (mock *MockBacktrackableNamespace) MetaCalls() []struct {
	Ident structural.Ident
} {
	var calls []struct {
		Ident structural.Ident
	}
	mock.lockMeta.RLock()
	calls = mock.calls.Meta
	mock.lockMeta.RUnlock()
	return calls
}

// Path calls PathFunc.
func (mock *MockBacktrackableNamespace) Path() string {
	if mock.PathFunc == nil {
		panic("MockBacktrackableNamespace.PathFunc: method is nil but BacktrackableNamespace.Path was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPath.Lock()
	mock.calls.Path = append(mock.calls.Path, callInfo)
	mock.lockPath.Unlock()
	return mock.PathFunc()
}

// PathCalls gets all the calls that were made to Path.
// Check the length with:
//
//	len(mockedBacktrackableNamespace.PathCalls())
func (mock *MockBacktrackableNamespace) PathCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPath.RLock()
	calls = mock.calls.Path
	mock.lockPath.RUnlock()
	return calls
}
