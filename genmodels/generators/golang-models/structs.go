package models

import (
	"path/filepath"
	"slices"
	"strconv"

	types "github.com/fredbi/core/genmodels/generators/extra-types"
	"github.com/fredbi/core/json/stores"
	"github.com/fredbi/core/jsonschema/analyzers"
	"github.com/fredbi/core/jsonschema/analyzers/structural"
)

type ImportsMap []AliasedImport

func (m ImportsMap) Merge(merged ImportsMap) ImportsMap {
	if len(merged) == 0 {
		return m
	}

	added := 0
	aliasIndex := make(map[string]string, len(m))

	for _, existing := range m {
		aliasIndex[existing.Alias] = existing.Package
	}
	for _, candidate := range merged {
		aliased, found := aliasIndex[candidate.Alias]
		if !found {
			aliasIndex[candidate.Alias] = candidate.Package
			added++

			continue
		}

		// alias conflict
		if candidate.Package != aliased {
			newAlias := m.deconflictAlias(candidate.Package, aliasIndex)
			aliasIndex[newAlias] = candidate.Package
			added++

			continue
		}

		// identical entries: nothing to do
	}

	result := make(ImportsMap, 0, len(m)+added)
	for alias, pkg := range aliasIndex {
		result = append(result, AliasedImport{Alias: alias, Package: pkg})
	}

	slices.SortFunc(result, func(a, b AliasedImport) int {
		switch {
		case a.Package < b.Package:
			return -1
		case a.Package > b.Package:
			return 1
		default:
			return 0
		}
	})

	return result
}

func (m ImportsMap) deconflictAlias(conflicting string, index map[string]string) (deconflicted string) {
	found := true
	for i := 2; !found; i++ {
		deconflicted = conflicting + strconv.Itoa(i)
		_, found = index[deconflicted]
	}

	return deconflicted
}

type LocationPath string // TODO: not sure this is useful

type GenSchemaTemplateOptions struct {
	*GenOptions
	TargetCodeFlags

	NeedsSerializer bool
	MarshalMode     MarshalMode
	JSONLibPath     string
	Serializer      SerializerSelector
}

// TargetModel holds the data model for templates generating models.
//
// There is one [TargetModel] structure per generated target file.
//
// A single [TargetModel] contains one or several [TargetSchema] to be generated in the same file.
type TargetModel struct {
	GenModelOptions
	TargetCodeFlags

	ID              analyzers.UniqueID // unique file qualifier, e.g. github.com/fredbi/core/models/model.go
	RelatedParent   analyzers.UniqueID // marks that a type, originally an anonymous schema and with an autogenerated type, has its parent there
	UltimateParent  analyzers.UniqueID // marks that a type, should be merged as a schema of this root
	Name            string             // original name (from the spec, if any), e.g. "model"
	Package         string             // package short name (e.g. "models")
	PackageLocation string             // relative path to the package (e.g. "models/subpackage/enums")
	FullPackage     string             // fully qualified package name (e.g. "github.com/fredbi/core/models")
	File            string             // file stem name without path or extension (e.g. "this_is_a_model")
	StdImports      ImportsMap         // imports from the standard library
	Imports         ImportsMap         // non-standard imports
	Schemas         []TargetSchema     // all the schemas to produce in a single source model file
}

func (m *TargetModel) MergeSchemas(from []TargetSchema) {
	m.Schemas = slices.Concat(m.Schemas, from)
}

// TargetCodeFlags instructs the generator about the kind of content to generate.
//
// This may be only a type definition with its methods,
// schema validation code split apart, or test code.
type TargetCodeFlags struct {
	NeedsOnlyValidation bool // a model with only validation code
	NeedsType           bool // the container requires a type declaration, like "type A {GoType}"
	NeedsTest           bool // the container requires test code
	NeedsValidation     bool // the container requires test code
}

type TargetCode string

func (k TargetCode) String() string {
	return string(k)
}

const (
	TargetCodeTypeDefinition     TargetCode = "type"
	TargetCodeTypeTest           TargetCode = "type_test"
	TargetCodeValidationOnly     TargetCode = "validation"
	TargetCodeValidationTestOnly TargetCode = "validation_test"
)

var (
	flagsForTypeDefinition = TargetCodeFlags{
		NeedsType:           true,
		NeedsValidation:     true,
		NeedsOnlyValidation: false,
		NeedsTest:           false,
	}

	flagsForTypeValidation = TargetCodeFlags{
		NeedsType:           false,
		NeedsValidation:     true,
		NeedsOnlyValidation: true,
		NeedsTest:           false,
	}

	flagsForTypeTest = TargetCodeFlags{
		NeedsType:           false,
		NeedsValidation:     true,
		NeedsOnlyValidation: false,
		NeedsTest:           true,
	}

	flagsForValidationTest = TargetCodeFlags{
		NeedsType:           false,
		NeedsValidation:     true,
		NeedsOnlyValidation: true,
		NeedsTest:           true,
	}
)

func (f TargetCodeFlags) TargetCode() string {
	if f.NeedsType {
		return TargetCodeTypeDefinition.String()
	}

	if f.NeedsTest {
		if f.NeedsOnlyValidation {
			return TargetCodeValidationTestOnly.String()
		}

		return TargetCodeTypeTest.String()
	}

	if f.NeedsOnlyValidation {
		return TargetCodeValidationOnly.String()
	}

	panic("internal error: unhandled target kind combination")
}

type GenModelOptions struct {
	*GenOptions
}

// FileName resolves the relative path to the file name.
func (m TargetModel) FileName() string {
	return filepath.Join(m.PackageLocation, m.File+".go")
}

type TargetSchema struct {
	GenSchemaTemplateOptions
	TypeDefinition
	TypeValidations

	Source structural.AnalyzedSchema
	// ParentDependencies []analyzers.UniqueID // UniqueID's of models this schema depends on
}

type Metadata struct {
	s            stores.Store       // avoids storing in memory all the comments & metadata text
	ID           analyzers.UniqueID // unique type identifier, e.g. github.com/fredbi/core/models.Model
	OriginalName string             // original name from the spec
	title        stores.Handle      // store.Handle
	description  stores.Handle      // store.Handle
	jsonComment  stores.Handle      // store.Handle
	Path         string
	Example      any
	Examples     []any
	Annotations  []string                  // reverse-spec annotations
	Report       []types.InformationReport // generation report: warnings, tracking decisions etc
	Related      []analyzers.UniqueID      // related types (e.g container -> children). Used in doc string.

	OpenAPIMetadata *OpenAPIMedata // nil if schema does not originate from an OAI schema or spec
}

func (m Metadata) Title() string {
	v := m.s.Get(m.title)

	return v.String()
}

func (m Metadata) Description() string {
	v := m.s.Get(m.description)

	return v.String()
}

func (m Metadata) JSONComment() string {
	v := m.s.Get(m.jsonComment)

	return v.String()
}

type OpenAPIMedata struct {
	Tags        []string
	ExternalDoc ExternalDocumentation
}

type ExternalDocumentation struct {
	s           stores.Store
	description stores.Handle
	URL         string
}

func (e ExternalDocumentation) Description() string {
	v := e.s.Get(e.description)

	return v.String()
}

type MarshalTemplateOptions struct {
}

type TypeValidations struct {
	HasValidations bool
	ReadOnly       bool
	WriteOnly      bool

	// TODO: embed JSON schema typed validations

	ValidatorInternals
}

type ValidatorInternals struct {
	KeyVar   string
	IndexVar string
}

type ContainerContextFlags struct {
	IsPointer   bool // the contained element is a pointer
	IsAnonymous bool // the contained element is anonymous (for structs, primitive types)
	IsEmbedded  bool // the contained element is an embedded type (for structs, interfaces)
}

type ContainerContext struct {
	ContainerContextFlags
	ReceiverName string
	Schema       *TargetSchema
}

// NamedContainerContext is used for structs and interfaces to name and element
type NamedContainerContext struct {
	ContainerContext

	Name       string // original name for this contained schema, from the spec (e.g. property name)
	Identifier string // go identifier for this contained schema
	StructTags string
	IsExported bool
}

type MethodContainerContext struct {
	Name              string
	Identifier        string // go identifier for this method, e.g. "GetProperty"
	ReceiverName      string
	MethodKind        MethodKindSelector
	IsPointerReceiver bool
	UnderlyingField   *TargetSchema // when the method is a Getter or Setter, we only specify the UnderlyingField, not the arrays below
	Parameters        []NamedContainerContext
	Returns           []ContainerContext
}

type ContainerFlags struct {
	kind TargetKind

	IsEnum      bool
	IsExternal  bool
	IsAliased   bool // type A = B
	IsRedefined bool // type A B
	IsElement   bool
	IsGeneric   bool
	IsNullable  bool // should support explicit "null" value vs undefined (this is not the same as IsPointer)

	HasDiscriminator bool
	HasEmbedded      bool // contains an embedded type (for structs, interfaces)
	HasInterface     bool // contains an interface
	HasStream        bool // contains an io.Reader or io.Writer
	HasEnum          bool // has some enum or const validation
}

func (f ContainerFlags) IsStruct() bool    { return f.kind == TargetKindStruct }
func (f ContainerFlags) IsSlice() bool     { return f.kind == TargetKindSlice }
func (f ContainerFlags) IsMap() bool       { return f.kind == TargetKindMap }
func (f ContainerFlags) IsAny() bool       { return f.kind == TargetKindAny }
func (f ContainerFlags) IsTuple() bool     { return f.kind == TargetKindTuple }
func (f ContainerFlags) IsStream() bool    { return f.kind == TargetKindStream }
func (f ContainerFlags) IsPrimitive() bool { return f.kind == TargetKindPrimitive }
func (f ContainerFlags) IsInterface() bool { return f.kind == TargetKindInterface }
func (f ContainerFlags) IsArray() bool     { return f.kind == TargetKindArray }

// IsNilable indicates that the contained object may take the go nil value (this is not the same as the JSON null value).
func (f ContainerFlags) IsNilable() bool {
	return f.IsInterface() || f.IsMap() || f.IsSlice() || f.IsAny() || f.IsStream()
}

// TypeDefinition describes a type definition statement.
type TypeDefinition struct {
	Metadata

	Identifier string // type identifier, as in "type A ..."
	GoType     string // type specification, as in "type A string", not applicable to structs or interfaces

	ContainerFlags

	// maps
	Key *ContainerContext

	// maps and slices
	Element *ContainerContext

	// structs & tuples
	Fields []NamedContainerContext

	// interfaces
	Methods []MethodContainerContext // GetX, SetX
	DiscriminatedTypes

	DefaultValue any
}

type DiscriminatedTypes struct {
	IsBaseType         bool
	DiscriminatorField string
	DiscriminatorValue string
}
